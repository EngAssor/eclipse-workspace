
FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002e52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002e52  00002ee6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f7  00800068  00800068  00002eee  2**0
                  ALLOC
  3 .stab         00004980  00000000  00000000  00002ef0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002bc6  00000000  00000000  00007870  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 99 0b 	jmp	0x1732	; 0x1732 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e5       	ldi	r30, 0x52	; 82
      68:	fe e2       	ldi	r31, 0x2E	; 46
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 36       	cpi	r26, 0x68	; 104
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a8 e6       	ldi	r26, 0x68	; 104
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 35       	cpi	r26, 0x5F	; 95
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 8f 08 	call	0x111e	; 0x111e <main>
      8a:	0c 94 27 17 	jmp	0x2e4e	; 0x2e4e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <TogelpinVal>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <TogelpinVal+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <TogelpinVal+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	89 83       	std	Y+1, r24	; 0x01
      a0:	6a 83       	std	Y+2, r22	; 0x02
      a2:	89 81       	ldd	r24, Y+1	; 0x01
      a4:	28 2f       	mov	r18, r24
      a6:	30 e0       	ldi	r19, 0x00	; 0
      a8:	3c 83       	std	Y+4, r19	; 0x04
      aa:	2b 83       	std	Y+3, r18	; 0x03
      ac:	8b 81       	ldd	r24, Y+3	; 0x03
      ae:	9c 81       	ldd	r25, Y+4	; 0x04
      b0:	81 30       	cpi	r24, 0x01	; 1
      b2:	91 05       	cpc	r25, r1
      b4:	49 f1       	breq	.+82     	; 0x108 <TogelpinVal+0x76>
      b6:	2b 81       	ldd	r18, Y+3	; 0x03
      b8:	3c 81       	ldd	r19, Y+4	; 0x04
      ba:	22 30       	cpi	r18, 0x02	; 2
      bc:	31 05       	cpc	r19, r1
      be:	2c f4       	brge	.+10     	; 0xca <TogelpinVal+0x38>
      c0:	8b 81       	ldd	r24, Y+3	; 0x03
      c2:	9c 81       	ldd	r25, Y+4	; 0x04
      c4:	00 97       	sbiw	r24, 0x00	; 0
      c6:	61 f0       	breq	.+24     	; 0xe0 <TogelpinVal+0x4e>
      c8:	5a c0       	rjmp	.+180    	; 0x17e <TogelpinVal+0xec>
      ca:	2b 81       	ldd	r18, Y+3	; 0x03
      cc:	3c 81       	ldd	r19, Y+4	; 0x04
      ce:	22 30       	cpi	r18, 0x02	; 2
      d0:	31 05       	cpc	r19, r1
      d2:	71 f1       	breq	.+92     	; 0x130 <TogelpinVal+0x9e>
      d4:	8b 81       	ldd	r24, Y+3	; 0x03
      d6:	9c 81       	ldd	r25, Y+4	; 0x04
      d8:	83 30       	cpi	r24, 0x03	; 3
      da:	91 05       	cpc	r25, r1
      dc:	e9 f1       	breq	.+122    	; 0x158 <TogelpinVal+0xc6>
      de:	4f c0       	rjmp	.+158    	; 0x17e <TogelpinVal+0xec>
      e0:	ab e3       	ldi	r26, 0x3B	; 59
      e2:	b0 e0       	ldi	r27, 0x00	; 0
      e4:	eb e3       	ldi	r30, 0x3B	; 59
      e6:	f0 e0       	ldi	r31, 0x00	; 0
      e8:	80 81       	ld	r24, Z
      ea:	48 2f       	mov	r20, r24
      ec:	8a 81       	ldd	r24, Y+2	; 0x02
      ee:	28 2f       	mov	r18, r24
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	81 e0       	ldi	r24, 0x01	; 1
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	02 2e       	mov	r0, r18
      f8:	02 c0       	rjmp	.+4      	; 0xfe <TogelpinVal+0x6c>
      fa:	88 0f       	add	r24, r24
      fc:	99 1f       	adc	r25, r25
      fe:	0a 94       	dec	r0
     100:	e2 f7       	brpl	.-8      	; 0xfa <TogelpinVal+0x68>
     102:	84 27       	eor	r24, r20
     104:	8c 93       	st	X, r24
     106:	3b c0       	rjmp	.+118    	; 0x17e <TogelpinVal+0xec>
     108:	a8 e3       	ldi	r26, 0x38	; 56
     10a:	b0 e0       	ldi	r27, 0x00	; 0
     10c:	e8 e3       	ldi	r30, 0x38	; 56
     10e:	f0 e0       	ldi	r31, 0x00	; 0
     110:	80 81       	ld	r24, Z
     112:	48 2f       	mov	r20, r24
     114:	8a 81       	ldd	r24, Y+2	; 0x02
     116:	28 2f       	mov	r18, r24
     118:	30 e0       	ldi	r19, 0x00	; 0
     11a:	81 e0       	ldi	r24, 0x01	; 1
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	02 2e       	mov	r0, r18
     120:	02 c0       	rjmp	.+4      	; 0x126 <TogelpinVal+0x94>
     122:	88 0f       	add	r24, r24
     124:	99 1f       	adc	r25, r25
     126:	0a 94       	dec	r0
     128:	e2 f7       	brpl	.-8      	; 0x122 <TogelpinVal+0x90>
     12a:	84 27       	eor	r24, r20
     12c:	8c 93       	st	X, r24
     12e:	27 c0       	rjmp	.+78     	; 0x17e <TogelpinVal+0xec>
     130:	a5 e3       	ldi	r26, 0x35	; 53
     132:	b0 e0       	ldi	r27, 0x00	; 0
     134:	e5 e3       	ldi	r30, 0x35	; 53
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	80 81       	ld	r24, Z
     13a:	48 2f       	mov	r20, r24
     13c:	8a 81       	ldd	r24, Y+2	; 0x02
     13e:	28 2f       	mov	r18, r24
     140:	30 e0       	ldi	r19, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	02 2e       	mov	r0, r18
     148:	02 c0       	rjmp	.+4      	; 0x14e <TogelpinVal+0xbc>
     14a:	88 0f       	add	r24, r24
     14c:	99 1f       	adc	r25, r25
     14e:	0a 94       	dec	r0
     150:	e2 f7       	brpl	.-8      	; 0x14a <TogelpinVal+0xb8>
     152:	84 27       	eor	r24, r20
     154:	8c 93       	st	X, r24
     156:	13 c0       	rjmp	.+38     	; 0x17e <TogelpinVal+0xec>
     158:	a2 e3       	ldi	r26, 0x32	; 50
     15a:	b0 e0       	ldi	r27, 0x00	; 0
     15c:	e2 e3       	ldi	r30, 0x32	; 50
     15e:	f0 e0       	ldi	r31, 0x00	; 0
     160:	80 81       	ld	r24, Z
     162:	48 2f       	mov	r20, r24
     164:	8a 81       	ldd	r24, Y+2	; 0x02
     166:	28 2f       	mov	r18, r24
     168:	30 e0       	ldi	r19, 0x00	; 0
     16a:	81 e0       	ldi	r24, 0x01	; 1
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	02 2e       	mov	r0, r18
     170:	02 c0       	rjmp	.+4      	; 0x176 <TogelpinVal+0xe4>
     172:	88 0f       	add	r24, r24
     174:	99 1f       	adc	r25, r25
     176:	0a 94       	dec	r0
     178:	e2 f7       	brpl	.-8      	; 0x172 <TogelpinVal+0xe0>
     17a:	84 27       	eor	r24, r20
     17c:	8c 93       	st	X, r24
     17e:	0f 90       	pop	r0
     180:	0f 90       	pop	r0
     182:	0f 90       	pop	r0
     184:	0f 90       	pop	r0
     186:	cf 91       	pop	r28
     188:	df 91       	pop	r29
     18a:	08 95       	ret

0000018c <DIO_VidSetPinDir>:

	}

}
void DIO_VidSetPinDir(u8 PinId,u8 PortId,u8 PinDir)
{
     18c:	df 93       	push	r29
     18e:	cf 93       	push	r28
     190:	cd b7       	in	r28, 0x3d	; 61
     192:	de b7       	in	r29, 0x3e	; 62
     194:	27 97       	sbiw	r28, 0x07	; 7
     196:	0f b6       	in	r0, 0x3f	; 63
     198:	f8 94       	cli
     19a:	de bf       	out	0x3e, r29	; 62
     19c:	0f be       	out	0x3f, r0	; 63
     19e:	cd bf       	out	0x3d, r28	; 61
     1a0:	89 83       	std	Y+1, r24	; 0x01
     1a2:	6a 83       	std	Y+2, r22	; 0x02
     1a4:	4b 83       	std	Y+3, r20	; 0x03
if((PortId<=DIO_PORTD)&&(PinId<=DIO_PIN7))
     1a6:	8a 81       	ldd	r24, Y+2	; 0x02
     1a8:	84 30       	cpi	r24, 0x04	; 4
     1aa:	08 f0       	brcs	.+2      	; 0x1ae <DIO_VidSetPinDir+0x22>
     1ac:	ee c0       	rjmp	.+476    	; 0x38a <DIO_VidSetPinDir+0x1fe>
     1ae:	89 81       	ldd	r24, Y+1	; 0x01
     1b0:	88 30       	cpi	r24, 0x08	; 8
     1b2:	08 f0       	brcs	.+2      	; 0x1b6 <DIO_VidSetPinDir+0x2a>
     1b4:	ea c0       	rjmp	.+468    	; 0x38a <DIO_VidSetPinDir+0x1fe>
{
if (PinDir == DIO_OUTPUT)
     1b6:	8b 81       	ldd	r24, Y+3	; 0x03
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	09 f0       	breq	.+2      	; 0x1be <DIO_VidSetPinDir+0x32>
     1bc:	6f c0       	rjmp	.+222    	; 0x29c <DIO_VidSetPinDir+0x110>
{
switch(PortId)
     1be:	8a 81       	ldd	r24, Y+2	; 0x02
     1c0:	28 2f       	mov	r18, r24
     1c2:	30 e0       	ldi	r19, 0x00	; 0
     1c4:	3f 83       	std	Y+7, r19	; 0x07
     1c6:	2e 83       	std	Y+6, r18	; 0x06
     1c8:	8e 81       	ldd	r24, Y+6	; 0x06
     1ca:	9f 81       	ldd	r25, Y+7	; 0x07
     1cc:	81 30       	cpi	r24, 0x01	; 1
     1ce:	91 05       	cpc	r25, r1
     1d0:	49 f1       	breq	.+82     	; 0x224 <DIO_VidSetPinDir+0x98>
     1d2:	2e 81       	ldd	r18, Y+6	; 0x06
     1d4:	3f 81       	ldd	r19, Y+7	; 0x07
     1d6:	22 30       	cpi	r18, 0x02	; 2
     1d8:	31 05       	cpc	r19, r1
     1da:	2c f4       	brge	.+10     	; 0x1e6 <DIO_VidSetPinDir+0x5a>
     1dc:	8e 81       	ldd	r24, Y+6	; 0x06
     1de:	9f 81       	ldd	r25, Y+7	; 0x07
     1e0:	00 97       	sbiw	r24, 0x00	; 0
     1e2:	61 f0       	breq	.+24     	; 0x1fc <DIO_VidSetPinDir+0x70>
     1e4:	d2 c0       	rjmp	.+420    	; 0x38a <DIO_VidSetPinDir+0x1fe>
     1e6:	2e 81       	ldd	r18, Y+6	; 0x06
     1e8:	3f 81       	ldd	r19, Y+7	; 0x07
     1ea:	22 30       	cpi	r18, 0x02	; 2
     1ec:	31 05       	cpc	r19, r1
     1ee:	71 f1       	breq	.+92     	; 0x24c <DIO_VidSetPinDir+0xc0>
     1f0:	8e 81       	ldd	r24, Y+6	; 0x06
     1f2:	9f 81       	ldd	r25, Y+7	; 0x07
     1f4:	83 30       	cpi	r24, 0x03	; 3
     1f6:	91 05       	cpc	r25, r1
     1f8:	e9 f1       	breq	.+122    	; 0x274 <DIO_VidSetPinDir+0xe8>
     1fa:	c7 c0       	rjmp	.+398    	; 0x38a <DIO_VidSetPinDir+0x1fe>
{
case DIO_PORTA :SET_BIT(DDRA_REG,PinId); break;
     1fc:	aa e3       	ldi	r26, 0x3A	; 58
     1fe:	b0 e0       	ldi	r27, 0x00	; 0
     200:	ea e3       	ldi	r30, 0x3A	; 58
     202:	f0 e0       	ldi	r31, 0x00	; 0
     204:	80 81       	ld	r24, Z
     206:	48 2f       	mov	r20, r24
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	28 2f       	mov	r18, r24
     20c:	30 e0       	ldi	r19, 0x00	; 0
     20e:	81 e0       	ldi	r24, 0x01	; 1
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	02 2e       	mov	r0, r18
     214:	02 c0       	rjmp	.+4      	; 0x21a <DIO_VidSetPinDir+0x8e>
     216:	88 0f       	add	r24, r24
     218:	99 1f       	adc	r25, r25
     21a:	0a 94       	dec	r0
     21c:	e2 f7       	brpl	.-8      	; 0x216 <DIO_VidSetPinDir+0x8a>
     21e:	84 2b       	or	r24, r20
     220:	8c 93       	st	X, r24
     222:	b3 c0       	rjmp	.+358    	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTB :SET_BIT(DDRB_REG,PinId); break;
     224:	a7 e3       	ldi	r26, 0x37	; 55
     226:	b0 e0       	ldi	r27, 0x00	; 0
     228:	e7 e3       	ldi	r30, 0x37	; 55
     22a:	f0 e0       	ldi	r31, 0x00	; 0
     22c:	80 81       	ld	r24, Z
     22e:	48 2f       	mov	r20, r24
     230:	89 81       	ldd	r24, Y+1	; 0x01
     232:	28 2f       	mov	r18, r24
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	02 2e       	mov	r0, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <DIO_VidSetPinDir+0xb6>
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	0a 94       	dec	r0
     244:	e2 f7       	brpl	.-8      	; 0x23e <DIO_VidSetPinDir+0xb2>
     246:	84 2b       	or	r24, r20
     248:	8c 93       	st	X, r24
     24a:	9f c0       	rjmp	.+318    	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTC :SET_BIT(DDRC_REG,PinId); break;
     24c:	a4 e3       	ldi	r26, 0x34	; 52
     24e:	b0 e0       	ldi	r27, 0x00	; 0
     250:	e4 e3       	ldi	r30, 0x34	; 52
     252:	f0 e0       	ldi	r31, 0x00	; 0
     254:	80 81       	ld	r24, Z
     256:	48 2f       	mov	r20, r24
     258:	89 81       	ldd	r24, Y+1	; 0x01
     25a:	28 2f       	mov	r18, r24
     25c:	30 e0       	ldi	r19, 0x00	; 0
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	90 e0       	ldi	r25, 0x00	; 0
     262:	02 2e       	mov	r0, r18
     264:	02 c0       	rjmp	.+4      	; 0x26a <DIO_VidSetPinDir+0xde>
     266:	88 0f       	add	r24, r24
     268:	99 1f       	adc	r25, r25
     26a:	0a 94       	dec	r0
     26c:	e2 f7       	brpl	.-8      	; 0x266 <DIO_VidSetPinDir+0xda>
     26e:	84 2b       	or	r24, r20
     270:	8c 93       	st	X, r24
     272:	8b c0       	rjmp	.+278    	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTD :SET_BIT(DDRD_REG,PinId); break;
     274:	a1 e3       	ldi	r26, 0x31	; 49
     276:	b0 e0       	ldi	r27, 0x00	; 0
     278:	e1 e3       	ldi	r30, 0x31	; 49
     27a:	f0 e0       	ldi	r31, 0x00	; 0
     27c:	80 81       	ld	r24, Z
     27e:	48 2f       	mov	r20, r24
     280:	89 81       	ldd	r24, Y+1	; 0x01
     282:	28 2f       	mov	r18, r24
     284:	30 e0       	ldi	r19, 0x00	; 0
     286:	81 e0       	ldi	r24, 0x01	; 1
     288:	90 e0       	ldi	r25, 0x00	; 0
     28a:	02 2e       	mov	r0, r18
     28c:	02 c0       	rjmp	.+4      	; 0x292 <DIO_VidSetPinDir+0x106>
     28e:	88 0f       	add	r24, r24
     290:	99 1f       	adc	r25, r25
     292:	0a 94       	dec	r0
     294:	e2 f7       	brpl	.-8      	; 0x28e <DIO_VidSetPinDir+0x102>
     296:	84 2b       	or	r24, r20
     298:	8c 93       	st	X, r24
     29a:	77 c0       	rjmp	.+238    	; 0x38a <DIO_VidSetPinDir+0x1fe>

}


}
else if (PinDir == DIO_INPUT)
     29c:	8b 81       	ldd	r24, Y+3	; 0x03
     29e:	88 23       	and	r24, r24
     2a0:	09 f0       	breq	.+2      	; 0x2a4 <DIO_VidSetPinDir+0x118>
     2a2:	73 c0       	rjmp	.+230    	; 0x38a <DIO_VidSetPinDir+0x1fe>
{
switch(PortId)
     2a4:	8a 81       	ldd	r24, Y+2	; 0x02
     2a6:	28 2f       	mov	r18, r24
     2a8:	30 e0       	ldi	r19, 0x00	; 0
     2aa:	3d 83       	std	Y+5, r19	; 0x05
     2ac:	2c 83       	std	Y+4, r18	; 0x04
     2ae:	8c 81       	ldd	r24, Y+4	; 0x04
     2b0:	9d 81       	ldd	r25, Y+5	; 0x05
     2b2:	81 30       	cpi	r24, 0x01	; 1
     2b4:	91 05       	cpc	r25, r1
     2b6:	59 f1       	breq	.+86     	; 0x30e <DIO_VidSetPinDir+0x182>
     2b8:	2c 81       	ldd	r18, Y+4	; 0x04
     2ba:	3d 81       	ldd	r19, Y+5	; 0x05
     2bc:	22 30       	cpi	r18, 0x02	; 2
     2be:	31 05       	cpc	r19, r1
     2c0:	2c f4       	brge	.+10     	; 0x2cc <DIO_VidSetPinDir+0x140>
     2c2:	8c 81       	ldd	r24, Y+4	; 0x04
     2c4:	9d 81       	ldd	r25, Y+5	; 0x05
     2c6:	00 97       	sbiw	r24, 0x00	; 0
     2c8:	69 f0       	breq	.+26     	; 0x2e4 <DIO_VidSetPinDir+0x158>
     2ca:	5f c0       	rjmp	.+190    	; 0x38a <DIO_VidSetPinDir+0x1fe>
     2cc:	2c 81       	ldd	r18, Y+4	; 0x04
     2ce:	3d 81       	ldd	r19, Y+5	; 0x05
     2d0:	22 30       	cpi	r18, 0x02	; 2
     2d2:	31 05       	cpc	r19, r1
     2d4:	89 f1       	breq	.+98     	; 0x338 <DIO_VidSetPinDir+0x1ac>
     2d6:	8c 81       	ldd	r24, Y+4	; 0x04
     2d8:	9d 81       	ldd	r25, Y+5	; 0x05
     2da:	83 30       	cpi	r24, 0x03	; 3
     2dc:	91 05       	cpc	r25, r1
     2de:	09 f4       	brne	.+2      	; 0x2e2 <DIO_VidSetPinDir+0x156>
     2e0:	40 c0       	rjmp	.+128    	; 0x362 <DIO_VidSetPinDir+0x1d6>
     2e2:	53 c0       	rjmp	.+166    	; 0x38a <DIO_VidSetPinDir+0x1fe>
{
case DIO_PORTA :CLR_BIT(DDRA_REG,PinId); break;
     2e4:	aa e3       	ldi	r26, 0x3A	; 58
     2e6:	b0 e0       	ldi	r27, 0x00	; 0
     2e8:	ea e3       	ldi	r30, 0x3A	; 58
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	48 2f       	mov	r20, r24
     2f0:	89 81       	ldd	r24, Y+1	; 0x01
     2f2:	28 2f       	mov	r18, r24
     2f4:	30 e0       	ldi	r19, 0x00	; 0
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	02 2e       	mov	r0, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_VidSetPinDir+0x176>
     2fe:	88 0f       	add	r24, r24
     300:	99 1f       	adc	r25, r25
     302:	0a 94       	dec	r0
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_VidSetPinDir+0x172>
     306:	80 95       	com	r24
     308:	84 23       	and	r24, r20
     30a:	8c 93       	st	X, r24
     30c:	3e c0       	rjmp	.+124    	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTB :CLR_BIT(DDRB_REG,PinId); break;
     30e:	a7 e3       	ldi	r26, 0x37	; 55
     310:	b0 e0       	ldi	r27, 0x00	; 0
     312:	e7 e3       	ldi	r30, 0x37	; 55
     314:	f0 e0       	ldi	r31, 0x00	; 0
     316:	80 81       	ld	r24, Z
     318:	48 2f       	mov	r20, r24
     31a:	89 81       	ldd	r24, Y+1	; 0x01
     31c:	28 2f       	mov	r18, r24
     31e:	30 e0       	ldi	r19, 0x00	; 0
     320:	81 e0       	ldi	r24, 0x01	; 1
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	02 2e       	mov	r0, r18
     326:	02 c0       	rjmp	.+4      	; 0x32c <DIO_VidSetPinDir+0x1a0>
     328:	88 0f       	add	r24, r24
     32a:	99 1f       	adc	r25, r25
     32c:	0a 94       	dec	r0
     32e:	e2 f7       	brpl	.-8      	; 0x328 <DIO_VidSetPinDir+0x19c>
     330:	80 95       	com	r24
     332:	84 23       	and	r24, r20
     334:	8c 93       	st	X, r24
     336:	29 c0       	rjmp	.+82     	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTC :CLR_BIT(DDRC_REG,PinId); break;
     338:	a4 e3       	ldi	r26, 0x34	; 52
     33a:	b0 e0       	ldi	r27, 0x00	; 0
     33c:	e4 e3       	ldi	r30, 0x34	; 52
     33e:	f0 e0       	ldi	r31, 0x00	; 0
     340:	80 81       	ld	r24, Z
     342:	48 2f       	mov	r20, r24
     344:	89 81       	ldd	r24, Y+1	; 0x01
     346:	28 2f       	mov	r18, r24
     348:	30 e0       	ldi	r19, 0x00	; 0
     34a:	81 e0       	ldi	r24, 0x01	; 1
     34c:	90 e0       	ldi	r25, 0x00	; 0
     34e:	02 2e       	mov	r0, r18
     350:	02 c0       	rjmp	.+4      	; 0x356 <DIO_VidSetPinDir+0x1ca>
     352:	88 0f       	add	r24, r24
     354:	99 1f       	adc	r25, r25
     356:	0a 94       	dec	r0
     358:	e2 f7       	brpl	.-8      	; 0x352 <DIO_VidSetPinDir+0x1c6>
     35a:	80 95       	com	r24
     35c:	84 23       	and	r24, r20
     35e:	8c 93       	st	X, r24
     360:	14 c0       	rjmp	.+40     	; 0x38a <DIO_VidSetPinDir+0x1fe>
case DIO_PORTD :CLR_BIT(DDRD_REG,PinId); break;
     362:	a1 e3       	ldi	r26, 0x31	; 49
     364:	b0 e0       	ldi	r27, 0x00	; 0
     366:	e1 e3       	ldi	r30, 0x31	; 49
     368:	f0 e0       	ldi	r31, 0x00	; 0
     36a:	80 81       	ld	r24, Z
     36c:	48 2f       	mov	r20, r24
     36e:	89 81       	ldd	r24, Y+1	; 0x01
     370:	28 2f       	mov	r18, r24
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	81 e0       	ldi	r24, 0x01	; 1
     376:	90 e0       	ldi	r25, 0x00	; 0
     378:	02 2e       	mov	r0, r18
     37a:	02 c0       	rjmp	.+4      	; 0x380 <DIO_VidSetPinDir+0x1f4>
     37c:	88 0f       	add	r24, r24
     37e:	99 1f       	adc	r25, r25
     380:	0a 94       	dec	r0
     382:	e2 f7       	brpl	.-8      	; 0x37c <DIO_VidSetPinDir+0x1f0>
     384:	80 95       	com	r24
     386:	84 23       	and	r24, r20
     388:	8c 93       	st	X, r24
}
else
{
// error
}
}
     38a:	27 96       	adiw	r28, 0x07	; 7
     38c:	0f b6       	in	r0, 0x3f	; 63
     38e:	f8 94       	cli
     390:	de bf       	out	0x3e, r29	; 62
     392:	0f be       	out	0x3f, r0	; 63
     394:	cd bf       	out	0x3d, r28	; 61
     396:	cf 91       	pop	r28
     398:	df 91       	pop	r29
     39a:	08 95       	ret

0000039c <DIO_VidSetPinVal>:
void DIO_VidSetPinVal(u8 PinId,u8 PortId,u8 PinVal)
{
     39c:	df 93       	push	r29
     39e:	cf 93       	push	r28
     3a0:	cd b7       	in	r28, 0x3d	; 61
     3a2:	de b7       	in	r29, 0x3e	; 62
     3a4:	27 97       	sbiw	r28, 0x07	; 7
     3a6:	0f b6       	in	r0, 0x3f	; 63
     3a8:	f8 94       	cli
     3aa:	de bf       	out	0x3e, r29	; 62
     3ac:	0f be       	out	0x3f, r0	; 63
     3ae:	cd bf       	out	0x3d, r28	; 61
     3b0:	89 83       	std	Y+1, r24	; 0x01
     3b2:	6a 83       	std	Y+2, r22	; 0x02
     3b4:	4b 83       	std	Y+3, r20	; 0x03
	if((PortId<=DIO_PORTD)&&(PinId<=DIO_PIN7))
     3b6:	8a 81       	ldd	r24, Y+2	; 0x02
     3b8:	84 30       	cpi	r24, 0x04	; 4
     3ba:	08 f0       	brcs	.+2      	; 0x3be <DIO_VidSetPinVal+0x22>
     3bc:	ee c0       	rjmp	.+476    	; 0x59a <DIO_VidSetPinVal+0x1fe>
     3be:	89 81       	ldd	r24, Y+1	; 0x01
     3c0:	88 30       	cpi	r24, 0x08	; 8
     3c2:	08 f0       	brcs	.+2      	; 0x3c6 <DIO_VidSetPinVal+0x2a>
     3c4:	ea c0       	rjmp	.+468    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	{
	if (PinVal == DIO_OUTPUT)
     3c6:	8b 81       	ldd	r24, Y+3	; 0x03
     3c8:	81 30       	cpi	r24, 0x01	; 1
     3ca:	09 f0       	breq	.+2      	; 0x3ce <DIO_VidSetPinVal+0x32>
     3cc:	6f c0       	rjmp	.+222    	; 0x4ac <DIO_VidSetPinVal+0x110>
	{
	switch(PortId)
     3ce:	8a 81       	ldd	r24, Y+2	; 0x02
     3d0:	28 2f       	mov	r18, r24
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	3f 83       	std	Y+7, r19	; 0x07
     3d6:	2e 83       	std	Y+6, r18	; 0x06
     3d8:	8e 81       	ldd	r24, Y+6	; 0x06
     3da:	9f 81       	ldd	r25, Y+7	; 0x07
     3dc:	81 30       	cpi	r24, 0x01	; 1
     3de:	91 05       	cpc	r25, r1
     3e0:	49 f1       	breq	.+82     	; 0x434 <DIO_VidSetPinVal+0x98>
     3e2:	2e 81       	ldd	r18, Y+6	; 0x06
     3e4:	3f 81       	ldd	r19, Y+7	; 0x07
     3e6:	22 30       	cpi	r18, 0x02	; 2
     3e8:	31 05       	cpc	r19, r1
     3ea:	2c f4       	brge	.+10     	; 0x3f6 <DIO_VidSetPinVal+0x5a>
     3ec:	8e 81       	ldd	r24, Y+6	; 0x06
     3ee:	9f 81       	ldd	r25, Y+7	; 0x07
     3f0:	00 97       	sbiw	r24, 0x00	; 0
     3f2:	61 f0       	breq	.+24     	; 0x40c <DIO_VidSetPinVal+0x70>
     3f4:	d2 c0       	rjmp	.+420    	; 0x59a <DIO_VidSetPinVal+0x1fe>
     3f6:	2e 81       	ldd	r18, Y+6	; 0x06
     3f8:	3f 81       	ldd	r19, Y+7	; 0x07
     3fa:	22 30       	cpi	r18, 0x02	; 2
     3fc:	31 05       	cpc	r19, r1
     3fe:	71 f1       	breq	.+92     	; 0x45c <DIO_VidSetPinVal+0xc0>
     400:	8e 81       	ldd	r24, Y+6	; 0x06
     402:	9f 81       	ldd	r25, Y+7	; 0x07
     404:	83 30       	cpi	r24, 0x03	; 3
     406:	91 05       	cpc	r25, r1
     408:	e9 f1       	breq	.+122    	; 0x484 <DIO_VidSetPinVal+0xe8>
     40a:	c7 c0       	rjmp	.+398    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	{
	case DIO_PORTA :SET_BIT(PORTA_REG,PinId);break;
     40c:	ab e3       	ldi	r26, 0x3B	; 59
     40e:	b0 e0       	ldi	r27, 0x00	; 0
     410:	eb e3       	ldi	r30, 0x3B	; 59
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	80 81       	ld	r24, Z
     416:	48 2f       	mov	r20, r24
     418:	89 81       	ldd	r24, Y+1	; 0x01
     41a:	28 2f       	mov	r18, r24
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	02 2e       	mov	r0, r18
     424:	02 c0       	rjmp	.+4      	; 0x42a <DIO_VidSetPinVal+0x8e>
     426:	88 0f       	add	r24, r24
     428:	99 1f       	adc	r25, r25
     42a:	0a 94       	dec	r0
     42c:	e2 f7       	brpl	.-8      	; 0x426 <DIO_VidSetPinVal+0x8a>
     42e:	84 2b       	or	r24, r20
     430:	8c 93       	st	X, r24
     432:	b3 c0       	rjmp	.+358    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTB :SET_BIT(PORTB_REG,PinId); break;
     434:	a8 e3       	ldi	r26, 0x38	; 56
     436:	b0 e0       	ldi	r27, 0x00	; 0
     438:	e8 e3       	ldi	r30, 0x38	; 56
     43a:	f0 e0       	ldi	r31, 0x00	; 0
     43c:	80 81       	ld	r24, Z
     43e:	48 2f       	mov	r20, r24
     440:	89 81       	ldd	r24, Y+1	; 0x01
     442:	28 2f       	mov	r18, r24
     444:	30 e0       	ldi	r19, 0x00	; 0
     446:	81 e0       	ldi	r24, 0x01	; 1
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	02 2e       	mov	r0, r18
     44c:	02 c0       	rjmp	.+4      	; 0x452 <DIO_VidSetPinVal+0xb6>
     44e:	88 0f       	add	r24, r24
     450:	99 1f       	adc	r25, r25
     452:	0a 94       	dec	r0
     454:	e2 f7       	brpl	.-8      	; 0x44e <DIO_VidSetPinVal+0xb2>
     456:	84 2b       	or	r24, r20
     458:	8c 93       	st	X, r24
     45a:	9f c0       	rjmp	.+318    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTC :SET_BIT(PORTC_REG,PinId); break;
     45c:	a5 e3       	ldi	r26, 0x35	; 53
     45e:	b0 e0       	ldi	r27, 0x00	; 0
     460:	e5 e3       	ldi	r30, 0x35	; 53
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	80 81       	ld	r24, Z
     466:	48 2f       	mov	r20, r24
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	28 2f       	mov	r18, r24
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	02 2e       	mov	r0, r18
     474:	02 c0       	rjmp	.+4      	; 0x47a <DIO_VidSetPinVal+0xde>
     476:	88 0f       	add	r24, r24
     478:	99 1f       	adc	r25, r25
     47a:	0a 94       	dec	r0
     47c:	e2 f7       	brpl	.-8      	; 0x476 <DIO_VidSetPinVal+0xda>
     47e:	84 2b       	or	r24, r20
     480:	8c 93       	st	X, r24
     482:	8b c0       	rjmp	.+278    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTD :SET_BIT(PORTD_REG,PinId);break;
     484:	a2 e3       	ldi	r26, 0x32	; 50
     486:	b0 e0       	ldi	r27, 0x00	; 0
     488:	e2 e3       	ldi	r30, 0x32	; 50
     48a:	f0 e0       	ldi	r31, 0x00	; 0
     48c:	80 81       	ld	r24, Z
     48e:	48 2f       	mov	r20, r24
     490:	89 81       	ldd	r24, Y+1	; 0x01
     492:	28 2f       	mov	r18, r24
     494:	30 e0       	ldi	r19, 0x00	; 0
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	02 2e       	mov	r0, r18
     49c:	02 c0       	rjmp	.+4      	; 0x4a2 <DIO_VidSetPinVal+0x106>
     49e:	88 0f       	add	r24, r24
     4a0:	99 1f       	adc	r25, r25
     4a2:	0a 94       	dec	r0
     4a4:	e2 f7       	brpl	.-8      	; 0x49e <DIO_VidSetPinVal+0x102>
     4a6:	84 2b       	or	r24, r20
     4a8:	8c 93       	st	X, r24
     4aa:	77 c0       	rjmp	.+238    	; 0x59a <DIO_VidSetPinVal+0x1fe>

	}


	}
	else if (PinVal == DIO_INPUT)
     4ac:	8b 81       	ldd	r24, Y+3	; 0x03
     4ae:	88 23       	and	r24, r24
     4b0:	09 f0       	breq	.+2      	; 0x4b4 <DIO_VidSetPinVal+0x118>
     4b2:	73 c0       	rjmp	.+230    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	{
	switch(PortId)
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	28 2f       	mov	r18, r24
     4b8:	30 e0       	ldi	r19, 0x00	; 0
     4ba:	3d 83       	std	Y+5, r19	; 0x05
     4bc:	2c 83       	std	Y+4, r18	; 0x04
     4be:	8c 81       	ldd	r24, Y+4	; 0x04
     4c0:	9d 81       	ldd	r25, Y+5	; 0x05
     4c2:	81 30       	cpi	r24, 0x01	; 1
     4c4:	91 05       	cpc	r25, r1
     4c6:	59 f1       	breq	.+86     	; 0x51e <DIO_VidSetPinVal+0x182>
     4c8:	2c 81       	ldd	r18, Y+4	; 0x04
     4ca:	3d 81       	ldd	r19, Y+5	; 0x05
     4cc:	22 30       	cpi	r18, 0x02	; 2
     4ce:	31 05       	cpc	r19, r1
     4d0:	2c f4       	brge	.+10     	; 0x4dc <DIO_VidSetPinVal+0x140>
     4d2:	8c 81       	ldd	r24, Y+4	; 0x04
     4d4:	9d 81       	ldd	r25, Y+5	; 0x05
     4d6:	00 97       	sbiw	r24, 0x00	; 0
     4d8:	69 f0       	breq	.+26     	; 0x4f4 <DIO_VidSetPinVal+0x158>
     4da:	5f c0       	rjmp	.+190    	; 0x59a <DIO_VidSetPinVal+0x1fe>
     4dc:	2c 81       	ldd	r18, Y+4	; 0x04
     4de:	3d 81       	ldd	r19, Y+5	; 0x05
     4e0:	22 30       	cpi	r18, 0x02	; 2
     4e2:	31 05       	cpc	r19, r1
     4e4:	89 f1       	breq	.+98     	; 0x548 <DIO_VidSetPinVal+0x1ac>
     4e6:	8c 81       	ldd	r24, Y+4	; 0x04
     4e8:	9d 81       	ldd	r25, Y+5	; 0x05
     4ea:	83 30       	cpi	r24, 0x03	; 3
     4ec:	91 05       	cpc	r25, r1
     4ee:	09 f4       	brne	.+2      	; 0x4f2 <DIO_VidSetPinVal+0x156>
     4f0:	40 c0       	rjmp	.+128    	; 0x572 <DIO_VidSetPinVal+0x1d6>
     4f2:	53 c0       	rjmp	.+166    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	{
	case DIO_PORTA :CLR_BIT(PORTA_REG,PinId); break;
     4f4:	ab e3       	ldi	r26, 0x3B	; 59
     4f6:	b0 e0       	ldi	r27, 0x00	; 0
     4f8:	eb e3       	ldi	r30, 0x3B	; 59
     4fa:	f0 e0       	ldi	r31, 0x00	; 0
     4fc:	80 81       	ld	r24, Z
     4fe:	48 2f       	mov	r20, r24
     500:	89 81       	ldd	r24, Y+1	; 0x01
     502:	28 2f       	mov	r18, r24
     504:	30 e0       	ldi	r19, 0x00	; 0
     506:	81 e0       	ldi	r24, 0x01	; 1
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	02 2e       	mov	r0, r18
     50c:	02 c0       	rjmp	.+4      	; 0x512 <DIO_VidSetPinVal+0x176>
     50e:	88 0f       	add	r24, r24
     510:	99 1f       	adc	r25, r25
     512:	0a 94       	dec	r0
     514:	e2 f7       	brpl	.-8      	; 0x50e <DIO_VidSetPinVal+0x172>
     516:	80 95       	com	r24
     518:	84 23       	and	r24, r20
     51a:	8c 93       	st	X, r24
     51c:	3e c0       	rjmp	.+124    	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTB :CLR_BIT(PORTB_REG,PinId);break;
     51e:	a8 e3       	ldi	r26, 0x38	; 56
     520:	b0 e0       	ldi	r27, 0x00	; 0
     522:	e8 e3       	ldi	r30, 0x38	; 56
     524:	f0 e0       	ldi	r31, 0x00	; 0
     526:	80 81       	ld	r24, Z
     528:	48 2f       	mov	r20, r24
     52a:	89 81       	ldd	r24, Y+1	; 0x01
     52c:	28 2f       	mov	r18, r24
     52e:	30 e0       	ldi	r19, 0x00	; 0
     530:	81 e0       	ldi	r24, 0x01	; 1
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	02 2e       	mov	r0, r18
     536:	02 c0       	rjmp	.+4      	; 0x53c <DIO_VidSetPinVal+0x1a0>
     538:	88 0f       	add	r24, r24
     53a:	99 1f       	adc	r25, r25
     53c:	0a 94       	dec	r0
     53e:	e2 f7       	brpl	.-8      	; 0x538 <DIO_VidSetPinVal+0x19c>
     540:	80 95       	com	r24
     542:	84 23       	and	r24, r20
     544:	8c 93       	st	X, r24
     546:	29 c0       	rjmp	.+82     	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTC :CLR_BIT(PORTC_REG,PinId); break;
     548:	a5 e3       	ldi	r26, 0x35	; 53
     54a:	b0 e0       	ldi	r27, 0x00	; 0
     54c:	e5 e3       	ldi	r30, 0x35	; 53
     54e:	f0 e0       	ldi	r31, 0x00	; 0
     550:	80 81       	ld	r24, Z
     552:	48 2f       	mov	r20, r24
     554:	89 81       	ldd	r24, Y+1	; 0x01
     556:	28 2f       	mov	r18, r24
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	81 e0       	ldi	r24, 0x01	; 1
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	02 2e       	mov	r0, r18
     560:	02 c0       	rjmp	.+4      	; 0x566 <DIO_VidSetPinVal+0x1ca>
     562:	88 0f       	add	r24, r24
     564:	99 1f       	adc	r25, r25
     566:	0a 94       	dec	r0
     568:	e2 f7       	brpl	.-8      	; 0x562 <DIO_VidSetPinVal+0x1c6>
     56a:	80 95       	com	r24
     56c:	84 23       	and	r24, r20
     56e:	8c 93       	st	X, r24
     570:	14 c0       	rjmp	.+40     	; 0x59a <DIO_VidSetPinVal+0x1fe>
	case DIO_PORTD :CLR_BIT(PORTD_REG,PinId); break;
     572:	a2 e3       	ldi	r26, 0x32	; 50
     574:	b0 e0       	ldi	r27, 0x00	; 0
     576:	e2 e3       	ldi	r30, 0x32	; 50
     578:	f0 e0       	ldi	r31, 0x00	; 0
     57a:	80 81       	ld	r24, Z
     57c:	48 2f       	mov	r20, r24
     57e:	89 81       	ldd	r24, Y+1	; 0x01
     580:	28 2f       	mov	r18, r24
     582:	30 e0       	ldi	r19, 0x00	; 0
     584:	81 e0       	ldi	r24, 0x01	; 1
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	02 2e       	mov	r0, r18
     58a:	02 c0       	rjmp	.+4      	; 0x590 <DIO_VidSetPinVal+0x1f4>
     58c:	88 0f       	add	r24, r24
     58e:	99 1f       	adc	r25, r25
     590:	0a 94       	dec	r0
     592:	e2 f7       	brpl	.-8      	; 0x58c <DIO_VidSetPinVal+0x1f0>
     594:	80 95       	com	r24
     596:	84 23       	and	r24, r20
     598:	8c 93       	st	X, r24
	else
	{
	// error
	}

}
     59a:	27 96       	adiw	r28, 0x07	; 7
     59c:	0f b6       	in	r0, 0x3f	; 63
     59e:	f8 94       	cli
     5a0:	de bf       	out	0x3e, r29	; 62
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	cd bf       	out	0x3d, r28	; 61
     5a6:	cf 91       	pop	r28
     5a8:	df 91       	pop	r29
     5aa:	08 95       	ret

000005ac <DIO_VidSetPortVal>:
void DIO_VidSetPortVal(u8 PortId,u8 PortVal)
{
     5ac:	df 93       	push	r29
     5ae:	cf 93       	push	r28
     5b0:	00 d0       	rcall	.+0      	; 0x5b2 <DIO_VidSetPortVal+0x6>
     5b2:	00 d0       	rcall	.+0      	; 0x5b4 <DIO_VidSetPortVal+0x8>
     5b4:	cd b7       	in	r28, 0x3d	; 61
     5b6:	de b7       	in	r29, 0x3e	; 62
     5b8:	89 83       	std	Y+1, r24	; 0x01
     5ba:	6a 83       	std	Y+2, r22	; 0x02


		if (PortId <= DIO_PORTD)
     5bc:	89 81       	ldd	r24, Y+1	; 0x01
     5be:	84 30       	cpi	r24, 0x04	; 4
     5c0:	90 f5       	brcc	.+100    	; 0x626 <DIO_VidSetPortVal+0x7a>
		{
		switch(PortId)
     5c2:	89 81       	ldd	r24, Y+1	; 0x01
     5c4:	28 2f       	mov	r18, r24
     5c6:	30 e0       	ldi	r19, 0x00	; 0
     5c8:	3c 83       	std	Y+4, r19	; 0x04
     5ca:	2b 83       	std	Y+3, r18	; 0x03
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	81 30       	cpi	r24, 0x01	; 1
     5d2:	91 05       	cpc	r25, r1
     5d4:	d1 f0       	breq	.+52     	; 0x60a <DIO_VidSetPortVal+0x5e>
     5d6:	2b 81       	ldd	r18, Y+3	; 0x03
     5d8:	3c 81       	ldd	r19, Y+4	; 0x04
     5da:	22 30       	cpi	r18, 0x02	; 2
     5dc:	31 05       	cpc	r19, r1
     5de:	2c f4       	brge	.+10     	; 0x5ea <DIO_VidSetPortVal+0x3e>
     5e0:	8b 81       	ldd	r24, Y+3	; 0x03
     5e2:	9c 81       	ldd	r25, Y+4	; 0x04
     5e4:	00 97       	sbiw	r24, 0x00	; 0
     5e6:	61 f0       	breq	.+24     	; 0x600 <DIO_VidSetPortVal+0x54>
     5e8:	1e c0       	rjmp	.+60     	; 0x626 <DIO_VidSetPortVal+0x7a>
     5ea:	2b 81       	ldd	r18, Y+3	; 0x03
     5ec:	3c 81       	ldd	r19, Y+4	; 0x04
     5ee:	22 30       	cpi	r18, 0x02	; 2
     5f0:	31 05       	cpc	r19, r1
     5f2:	81 f0       	breq	.+32     	; 0x614 <DIO_VidSetPortVal+0x68>
     5f4:	8b 81       	ldd	r24, Y+3	; 0x03
     5f6:	9c 81       	ldd	r25, Y+4	; 0x04
     5f8:	83 30       	cpi	r24, 0x03	; 3
     5fa:	91 05       	cpc	r25, r1
     5fc:	81 f0       	breq	.+32     	; 0x61e <DIO_VidSetPortVal+0x72>
     5fe:	13 c0       	rjmp	.+38     	; 0x626 <DIO_VidSetPortVal+0x7a>
		{
		case DIO_PORTA :PORTA_REG=PortVal; break;
     600:	eb e3       	ldi	r30, 0x3B	; 59
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	8a 81       	ldd	r24, Y+2	; 0x02
     606:	80 83       	st	Z, r24
     608:	0e c0       	rjmp	.+28     	; 0x626 <DIO_VidSetPortVal+0x7a>
		case DIO_PORTB :PORTB_REG=PortVal; break;
     60a:	e8 e3       	ldi	r30, 0x38	; 56
     60c:	f0 e0       	ldi	r31, 0x00	; 0
     60e:	8a 81       	ldd	r24, Y+2	; 0x02
     610:	80 83       	st	Z, r24
     612:	09 c0       	rjmp	.+18     	; 0x626 <DIO_VidSetPortVal+0x7a>
		case DIO_PORTC :PORTC_REG=PortVal; break;
     614:	e5 e3       	ldi	r30, 0x35	; 53
     616:	f0 e0       	ldi	r31, 0x00	; 0
     618:	8a 81       	ldd	r24, Y+2	; 0x02
     61a:	80 83       	st	Z, r24
     61c:	04 c0       	rjmp	.+8      	; 0x626 <DIO_VidSetPortVal+0x7a>
		case DIO_PORTD :PORTD_REG=PortVal; break;
     61e:	e2 e3       	ldi	r30, 0x32	; 50
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	8a 81       	ldd	r24, Y+2	; 0x02
     624:	80 83       	st	Z, r24
		}
	else
		{
		//error
		}
}
     626:	0f 90       	pop	r0
     628:	0f 90       	pop	r0
     62a:	0f 90       	pop	r0
     62c:	0f 90       	pop	r0
     62e:	cf 91       	pop	r28
     630:	df 91       	pop	r29
     632:	08 95       	ret

00000634 <DIO_VidSetPortDir>:


void DIO_VidSetPortDir(u8 PortId,u8 PortDir)
{
     634:	df 93       	push	r29
     636:	cf 93       	push	r28
     638:	00 d0       	rcall	.+0      	; 0x63a <DIO_VidSetPortDir+0x6>
     63a:	00 d0       	rcall	.+0      	; 0x63c <DIO_VidSetPortDir+0x8>
     63c:	cd b7       	in	r28, 0x3d	; 61
     63e:	de b7       	in	r29, 0x3e	; 62
     640:	89 83       	std	Y+1, r24	; 0x01
     642:	6a 83       	std	Y+2, r22	; 0x02
if(PortId<=DIO_PORTD)
     644:	89 81       	ldd	r24, Y+1	; 0x01
     646:	84 30       	cpi	r24, 0x04	; 4
     648:	90 f5       	brcc	.+100    	; 0x6ae <DIO_VidSetPortDir+0x7a>
{
switch(PortId)
     64a:	89 81       	ldd	r24, Y+1	; 0x01
     64c:	28 2f       	mov	r18, r24
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	3c 83       	std	Y+4, r19	; 0x04
     652:	2b 83       	std	Y+3, r18	; 0x03
     654:	8b 81       	ldd	r24, Y+3	; 0x03
     656:	9c 81       	ldd	r25, Y+4	; 0x04
     658:	81 30       	cpi	r24, 0x01	; 1
     65a:	91 05       	cpc	r25, r1
     65c:	d1 f0       	breq	.+52     	; 0x692 <DIO_VidSetPortDir+0x5e>
     65e:	2b 81       	ldd	r18, Y+3	; 0x03
     660:	3c 81       	ldd	r19, Y+4	; 0x04
     662:	22 30       	cpi	r18, 0x02	; 2
     664:	31 05       	cpc	r19, r1
     666:	2c f4       	brge	.+10     	; 0x672 <DIO_VidSetPortDir+0x3e>
     668:	8b 81       	ldd	r24, Y+3	; 0x03
     66a:	9c 81       	ldd	r25, Y+4	; 0x04
     66c:	00 97       	sbiw	r24, 0x00	; 0
     66e:	61 f0       	breq	.+24     	; 0x688 <DIO_VidSetPortDir+0x54>
     670:	1e c0       	rjmp	.+60     	; 0x6ae <DIO_VidSetPortDir+0x7a>
     672:	2b 81       	ldd	r18, Y+3	; 0x03
     674:	3c 81       	ldd	r19, Y+4	; 0x04
     676:	22 30       	cpi	r18, 0x02	; 2
     678:	31 05       	cpc	r19, r1
     67a:	81 f0       	breq	.+32     	; 0x69c <DIO_VidSetPortDir+0x68>
     67c:	8b 81       	ldd	r24, Y+3	; 0x03
     67e:	9c 81       	ldd	r25, Y+4	; 0x04
     680:	83 30       	cpi	r24, 0x03	; 3
     682:	91 05       	cpc	r25, r1
     684:	81 f0       	breq	.+32     	; 0x6a6 <DIO_VidSetPortDir+0x72>
     686:	13 c0       	rjmp	.+38     	; 0x6ae <DIO_VidSetPortDir+0x7a>
{
case DIO_PORTA :DDRA_REG=PortDir; break;
     688:	ea e3       	ldi	r30, 0x3A	; 58
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	8a 81       	ldd	r24, Y+2	; 0x02
     68e:	80 83       	st	Z, r24
     690:	0e c0       	rjmp	.+28     	; 0x6ae <DIO_VidSetPortDir+0x7a>
case DIO_PORTB :DDRB_REG=PortDir; break;
     692:	e7 e3       	ldi	r30, 0x37	; 55
     694:	f0 e0       	ldi	r31, 0x00	; 0
     696:	8a 81       	ldd	r24, Y+2	; 0x02
     698:	80 83       	st	Z, r24
     69a:	09 c0       	rjmp	.+18     	; 0x6ae <DIO_VidSetPortDir+0x7a>
case DIO_PORTC :DDRC_REG=PortDir; break;
     69c:	e4 e3       	ldi	r30, 0x34	; 52
     69e:	f0 e0       	ldi	r31, 0x00	; 0
     6a0:	8a 81       	ldd	r24, Y+2	; 0x02
     6a2:	80 83       	st	Z, r24
     6a4:	04 c0       	rjmp	.+8      	; 0x6ae <DIO_VidSetPortDir+0x7a>
case DIO_PORTD :DDRD_REG=PortDir; break;
     6a6:	e1 e3       	ldi	r30, 0x31	; 49
     6a8:	f0 e0       	ldi	r31, 0x00	; 0
     6aa:	8a 81       	ldd	r24, Y+2	; 0x02
     6ac:	80 83       	st	Z, r24
}
else
{
//error
}
}
     6ae:	0f 90       	pop	r0
     6b0:	0f 90       	pop	r0
     6b2:	0f 90       	pop	r0
     6b4:	0f 90       	pop	r0
     6b6:	cf 91       	pop	r28
     6b8:	df 91       	pop	r29
     6ba:	08 95       	ret

000006bc <DIO_u8GetPinVal>:
u8 DIO_u8GetPinVal(u8 PortId,u8 PinId)
{
     6bc:	df 93       	push	r29
     6be:	cf 93       	push	r28
     6c0:	00 d0       	rcall	.+0      	; 0x6c2 <DIO_u8GetPinVal+0x6>
     6c2:	00 d0       	rcall	.+0      	; 0x6c4 <DIO_u8GetPinVal+0x8>
     6c4:	00 d0       	rcall	.+0      	; 0x6c6 <DIO_u8GetPinVal+0xa>
     6c6:	cd b7       	in	r28, 0x3d	; 61
     6c8:	de b7       	in	r29, 0x3e	; 62
     6ca:	8a 83       	std	Y+2, r24	; 0x02
     6cc:	6b 83       	std	Y+3, r22	; 0x03
u8 PinState=0xff;//means wrong input (port id or pin id)
     6ce:	8f ef       	ldi	r24, 0xFF	; 255
     6d0:	89 83       	std	Y+1, r24	; 0x01
if((PortId<=DIO_PORTD)&&(PinId<=DIO_PIN7))
     6d2:	8a 81       	ldd	r24, Y+2	; 0x02
     6d4:	84 30       	cpi	r24, 0x04	; 4
     6d6:	08 f0       	brcs	.+2      	; 0x6da <DIO_u8GetPinVal+0x1e>
     6d8:	6e c0       	rjmp	.+220    	; 0x7b6 <DIO_u8GetPinVal+0xfa>
     6da:	8b 81       	ldd	r24, Y+3	; 0x03
     6dc:	88 30       	cpi	r24, 0x08	; 8
     6de:	08 f0       	brcs	.+2      	; 0x6e2 <DIO_u8GetPinVal+0x26>
     6e0:	6a c0       	rjmp	.+212    	; 0x7b6 <DIO_u8GetPinVal+0xfa>
{
	switch(PortId)
     6e2:	8a 81       	ldd	r24, Y+2	; 0x02
     6e4:	28 2f       	mov	r18, r24
     6e6:	30 e0       	ldi	r19, 0x00	; 0
     6e8:	3e 83       	std	Y+6, r19	; 0x06
     6ea:	2d 83       	std	Y+5, r18	; 0x05
     6ec:	4d 81       	ldd	r20, Y+5	; 0x05
     6ee:	5e 81       	ldd	r21, Y+6	; 0x06
     6f0:	41 30       	cpi	r20, 0x01	; 1
     6f2:	51 05       	cpc	r21, r1
     6f4:	41 f1       	breq	.+80     	; 0x746 <DIO_u8GetPinVal+0x8a>
     6f6:	8d 81       	ldd	r24, Y+5	; 0x05
     6f8:	9e 81       	ldd	r25, Y+6	; 0x06
     6fa:	82 30       	cpi	r24, 0x02	; 2
     6fc:	91 05       	cpc	r25, r1
     6fe:	34 f4       	brge	.+12     	; 0x70c <DIO_u8GetPinVal+0x50>
     700:	2d 81       	ldd	r18, Y+5	; 0x05
     702:	3e 81       	ldd	r19, Y+6	; 0x06
     704:	21 15       	cp	r18, r1
     706:	31 05       	cpc	r19, r1
     708:	61 f0       	breq	.+24     	; 0x722 <DIO_u8GetPinVal+0x66>
     70a:	52 c0       	rjmp	.+164    	; 0x7b0 <DIO_u8GetPinVal+0xf4>
     70c:	4d 81       	ldd	r20, Y+5	; 0x05
     70e:	5e 81       	ldd	r21, Y+6	; 0x06
     710:	42 30       	cpi	r20, 0x02	; 2
     712:	51 05       	cpc	r21, r1
     714:	51 f1       	breq	.+84     	; 0x76a <DIO_u8GetPinVal+0xae>
     716:	8d 81       	ldd	r24, Y+5	; 0x05
     718:	9e 81       	ldd	r25, Y+6	; 0x06
     71a:	83 30       	cpi	r24, 0x03	; 3
     71c:	91 05       	cpc	r25, r1
     71e:	b9 f1       	breq	.+110    	; 0x78e <DIO_u8GetPinVal+0xd2>
     720:	47 c0       	rjmp	.+142    	; 0x7b0 <DIO_u8GetPinVal+0xf4>
	{
	case DIO_PORTA :PinState=GET_BIT(PINA_REG,PinId); break;
     722:	e9 e3       	ldi	r30, 0x39	; 57
     724:	f0 e0       	ldi	r31, 0x00	; 0
     726:	80 81       	ld	r24, Z
     728:	28 2f       	mov	r18, r24
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	8b 81       	ldd	r24, Y+3	; 0x03
     72e:	88 2f       	mov	r24, r24
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	a9 01       	movw	r20, r18
     734:	02 c0       	rjmp	.+4      	; 0x73a <DIO_u8GetPinVal+0x7e>
     736:	55 95       	asr	r21
     738:	47 95       	ror	r20
     73a:	8a 95       	dec	r24
     73c:	e2 f7       	brpl	.-8      	; 0x736 <DIO_u8GetPinVal+0x7a>
     73e:	ca 01       	movw	r24, r20
     740:	81 70       	andi	r24, 0x01	; 1
     742:	89 83       	std	Y+1, r24	; 0x01
     744:	35 c0       	rjmp	.+106    	; 0x7b0 <DIO_u8GetPinVal+0xf4>
	case DIO_PORTB :PinState=GET_BIT(PINB_REG,PinId); break;
     746:	e6 e3       	ldi	r30, 0x36	; 54
     748:	f0 e0       	ldi	r31, 0x00	; 0
     74a:	80 81       	ld	r24, Z
     74c:	28 2f       	mov	r18, r24
     74e:	30 e0       	ldi	r19, 0x00	; 0
     750:	8b 81       	ldd	r24, Y+3	; 0x03
     752:	88 2f       	mov	r24, r24
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	a9 01       	movw	r20, r18
     758:	02 c0       	rjmp	.+4      	; 0x75e <DIO_u8GetPinVal+0xa2>
     75a:	55 95       	asr	r21
     75c:	47 95       	ror	r20
     75e:	8a 95       	dec	r24
     760:	e2 f7       	brpl	.-8      	; 0x75a <DIO_u8GetPinVal+0x9e>
     762:	ca 01       	movw	r24, r20
     764:	81 70       	andi	r24, 0x01	; 1
     766:	89 83       	std	Y+1, r24	; 0x01
     768:	23 c0       	rjmp	.+70     	; 0x7b0 <DIO_u8GetPinVal+0xf4>
	case DIO_PORTC :PinState=GET_BIT(PINC_REG,PinId); break;
     76a:	e3 e3       	ldi	r30, 0x33	; 51
     76c:	f0 e0       	ldi	r31, 0x00	; 0
     76e:	80 81       	ld	r24, Z
     770:	28 2f       	mov	r18, r24
     772:	30 e0       	ldi	r19, 0x00	; 0
     774:	8b 81       	ldd	r24, Y+3	; 0x03
     776:	88 2f       	mov	r24, r24
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	a9 01       	movw	r20, r18
     77c:	02 c0       	rjmp	.+4      	; 0x782 <DIO_u8GetPinVal+0xc6>
     77e:	55 95       	asr	r21
     780:	47 95       	ror	r20
     782:	8a 95       	dec	r24
     784:	e2 f7       	brpl	.-8      	; 0x77e <DIO_u8GetPinVal+0xc2>
     786:	ca 01       	movw	r24, r20
     788:	81 70       	andi	r24, 0x01	; 1
     78a:	89 83       	std	Y+1, r24	; 0x01
     78c:	11 c0       	rjmp	.+34     	; 0x7b0 <DIO_u8GetPinVal+0xf4>
	case DIO_PORTD :PinState=GET_BIT(PIND_REG,PinId); break;
     78e:	e0 e3       	ldi	r30, 0x30	; 48
     790:	f0 e0       	ldi	r31, 0x00	; 0
     792:	80 81       	ld	r24, Z
     794:	28 2f       	mov	r18, r24
     796:	30 e0       	ldi	r19, 0x00	; 0
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	88 2f       	mov	r24, r24
     79c:	90 e0       	ldi	r25, 0x00	; 0
     79e:	a9 01       	movw	r20, r18
     7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <DIO_u8GetPinVal+0xea>
     7a2:	55 95       	asr	r21
     7a4:	47 95       	ror	r20
     7a6:	8a 95       	dec	r24
     7a8:	e2 f7       	brpl	.-8      	; 0x7a2 <DIO_u8GetPinVal+0xe6>
     7aa:	ca 01       	movw	r24, r20
     7ac:	81 70       	andi	r24, 0x01	; 1
     7ae:	89 83       	std	Y+1, r24	; 0x01
	}
	return PinState;
     7b0:	59 81       	ldd	r21, Y+1	; 0x01
     7b2:	5c 83       	std	Y+4, r21	; 0x04
     7b4:	01 c0       	rjmp	.+2      	; 0x7b8 <DIO_u8GetPinVal+0xfc>

}
else
{
	return 0; //error
     7b6:	1c 82       	std	Y+4, r1	; 0x04
     7b8:	8c 81       	ldd	r24, Y+4	; 0x04
}
}
     7ba:	26 96       	adiw	r28, 0x06	; 6
     7bc:	0f b6       	in	r0, 0x3f	; 63
     7be:	f8 94       	cli
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	cd bf       	out	0x3d, r28	; 61
     7c6:	cf 91       	pop	r28
     7c8:	df 91       	pop	r29
     7ca:	08 95       	ret

000007cc <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     7cc:	df 93       	push	r29
     7ce:	cf 93       	push	r28
     7d0:	cd b7       	in	r28, 0x3d	; 61
     7d2:	de b7       	in	r29, 0x3e	; 62
     7d4:	27 97       	sbiw	r28, 0x07	; 7
     7d6:	0f b6       	in	r0, 0x3f	; 63
     7d8:	f8 94       	cli
     7da:	de bf       	out	0x3e, r29	; 62
     7dc:	0f be       	out	0x3f, r0	; 63
     7de:	cd bf       	out	0x3d, r28	; 61
     7e0:	9d 83       	std	Y+5, r25	; 0x05
     7e2:	8c 83       	std	Y+4, r24	; 0x04
     7e4:	6e 83       	std	Y+6, r22	; 0x06
     7e6:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     7e8:	8a e1       	ldi	r24, 0x1A	; 26
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	0e 94 be 06 	call	0xd7c	; 0xd7c <pvPortMalloc>
     7f0:	9a 83       	std	Y+2, r25	; 0x02
     7f2:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     7f4:	89 81       	ldd	r24, Y+1	; 0x01
     7f6:	9a 81       	ldd	r25, Y+2	; 0x02
     7f8:	00 97       	sbiw	r24, 0x00	; 0
     7fa:	09 f4       	brne	.+2      	; 0x7fe <xCoRoutineCreate+0x32>
     7fc:	6f c0       	rjmp	.+222    	; 0x8dc <__stack+0x7d>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     7fe:	80 91 68 00 	lds	r24, 0x0068
     802:	90 91 69 00 	lds	r25, 0x0069
     806:	00 97       	sbiw	r24, 0x00	; 0
     808:	41 f4       	brne	.+16     	; 0x81a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     80a:	89 81       	ldd	r24, Y+1	; 0x01
     80c:	9a 81       	ldd	r25, Y+2	; 0x02
     80e:	90 93 69 00 	sts	0x0069, r25
     812:	80 93 68 00 	sts	0x0068, r24
			prvInitialiseCoRoutineLists();
     816:	0e 94 4d 06 	call	0xc9a	; 0xc9a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     81a:	8e 81       	ldd	r24, Y+6	; 0x06
     81c:	82 30       	cpi	r24, 0x02	; 2
     81e:	10 f0       	brcs	.+4      	; 0x824 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     824:	e9 81       	ldd	r30, Y+1	; 0x01
     826:	fa 81       	ldd	r31, Y+2	; 0x02
     828:	11 8e       	std	Z+25, r1	; 0x19
     82a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     82c:	e9 81       	ldd	r30, Y+1	; 0x01
     82e:	fa 81       	ldd	r31, Y+2	; 0x02
     830:	8e 81       	ldd	r24, Y+6	; 0x06
     832:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     834:	e9 81       	ldd	r30, Y+1	; 0x01
     836:	fa 81       	ldd	r31, Y+2	; 0x02
     838:	8f 81       	ldd	r24, Y+7	; 0x07
     83a:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     83c:	e9 81       	ldd	r30, Y+1	; 0x01
     83e:	fa 81       	ldd	r31, Y+2	; 0x02
     840:	8c 81       	ldd	r24, Y+4	; 0x04
     842:	9d 81       	ldd	r25, Y+5	; 0x05
     844:	91 83       	std	Z+1, r25	; 0x01
     846:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     848:	89 81       	ldd	r24, Y+1	; 0x01
     84a:	9a 81       	ldd	r25, Y+2	; 0x02
     84c:	02 96       	adiw	r24, 0x02	; 2
     84e:	0e 94 54 07 	call	0xea8	; 0xea8 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     852:	89 81       	ldd	r24, Y+1	; 0x01
     854:	9a 81       	ldd	r25, Y+2	; 0x02
     856:	0c 96       	adiw	r24, 0x0c	; 12
     858:	0e 94 54 07 	call	0xea8	; 0xea8 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     85c:	e9 81       	ldd	r30, Y+1	; 0x01
     85e:	fa 81       	ldd	r31, Y+2	; 0x02
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	9a 81       	ldd	r25, Y+2	; 0x02
     864:	91 87       	std	Z+9, r25	; 0x09
     866:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     868:	e9 81       	ldd	r30, Y+1	; 0x01
     86a:	fa 81       	ldd	r31, Y+2	; 0x02
     86c:	89 81       	ldd	r24, Y+1	; 0x01
     86e:	9a 81       	ldd	r25, Y+2	; 0x02
     870:	93 8b       	std	Z+19, r25	; 0x13
     872:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     874:	8e 81       	ldd	r24, Y+6	; 0x06
     876:	28 2f       	mov	r18, r24
     878:	30 e0       	ldi	r19, 0x00	; 0
     87a:	85 e0       	ldi	r24, 0x05	; 5
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	82 1b       	sub	r24, r18
     880:	93 0b       	sbc	r25, r19
     882:	e9 81       	ldd	r30, Y+1	; 0x01
     884:	fa 81       	ldd	r31, Y+2	; 0x02
     886:	95 87       	std	Z+13, r25	; 0x0d
     888:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     88a:	e9 81       	ldd	r30, Y+1	; 0x01
     88c:	fa 81       	ldd	r31, Y+2	; 0x02
     88e:	96 89       	ldd	r25, Z+22	; 0x16
     890:	80 91 6a 00 	lds	r24, 0x006A
     894:	89 17       	cp	r24, r25
     896:	28 f4       	brcc	.+10     	; 0x8a2 <__stack+0x43>
     898:	e9 81       	ldd	r30, Y+1	; 0x01
     89a:	fa 81       	ldd	r31, Y+2	; 0x02
     89c:	86 89       	ldd	r24, Z+22	; 0x16
     89e:	80 93 6a 00 	sts	0x006A, r24
     8a2:	e9 81       	ldd	r30, Y+1	; 0x01
     8a4:	fa 81       	ldd	r31, Y+2	; 0x02
     8a6:	86 89       	ldd	r24, Z+22	; 0x16
     8a8:	28 2f       	mov	r18, r24
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	c9 01       	movw	r24, r18
     8ae:	88 0f       	add	r24, r24
     8b0:	99 1f       	adc	r25, r25
     8b2:	88 0f       	add	r24, r24
     8b4:	99 1f       	adc	r25, r25
     8b6:	88 0f       	add	r24, r24
     8b8:	99 1f       	adc	r25, r25
     8ba:	82 0f       	add	r24, r18
     8bc:	93 1f       	adc	r25, r19
     8be:	ac 01       	movw	r20, r24
     8c0:	4f 58       	subi	r20, 0x8F	; 143
     8c2:	5f 4f       	sbci	r21, 0xFF	; 255
     8c4:	89 81       	ldd	r24, Y+1	; 0x01
     8c6:	9a 81       	ldd	r25, Y+2	; 0x02
     8c8:	9c 01       	movw	r18, r24
     8ca:	2e 5f       	subi	r18, 0xFE	; 254
     8cc:	3f 4f       	sbci	r19, 0xFF	; 255
     8ce:	ca 01       	movw	r24, r20
     8d0:	b9 01       	movw	r22, r18
     8d2:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>

		xReturn = pdPASS;
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	8b 83       	std	Y+3, r24	; 0x03
     8da:	02 c0       	rjmp	.+4      	; 0x8e0 <__stack+0x81>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     8dc:	8f ef       	ldi	r24, 0xFF	; 255
     8de:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     8e0:	8b 81       	ldd	r24, Y+3	; 0x03
}
     8e2:	27 96       	adiw	r28, 0x07	; 7
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	de bf       	out	0x3e, r29	; 62
     8ea:	0f be       	out	0x3f, r0	; 63
     8ec:	cd bf       	out	0x3d, r28	; 61
     8ee:	cf 91       	pop	r28
     8f0:	df 91       	pop	r29
     8f2:	08 95       	ret

000008f4 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     8f4:	df 93       	push	r29
     8f6:	cf 93       	push	r28
     8f8:	00 d0       	rcall	.+0      	; 0x8fa <vCoRoutineAddToDelayedList+0x6>
     8fa:	00 d0       	rcall	.+0      	; 0x8fc <vCoRoutineAddToDelayedList+0x8>
     8fc:	00 d0       	rcall	.+0      	; 0x8fe <vCoRoutineAddToDelayedList+0xa>
     8fe:	cd b7       	in	r28, 0x3d	; 61
     900:	de b7       	in	r29, 0x3e	; 62
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
     906:	7e 83       	std	Y+6, r23	; 0x06
     908:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     90a:	20 91 6b 00 	lds	r18, 0x006B
     90e:	30 91 6c 00 	lds	r19, 0x006C
     912:	8b 81       	ldd	r24, Y+3	; 0x03
     914:	9c 81       	ldd	r25, Y+4	; 0x04
     916:	82 0f       	add	r24, r18
     918:	93 1f       	adc	r25, r19
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     91e:	80 91 68 00 	lds	r24, 0x0068
     922:	90 91 69 00 	lds	r25, 0x0069
     926:	02 96       	adiw	r24, 0x02	; 2
     928:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     92c:	e0 91 68 00 	lds	r30, 0x0068
     930:	f0 91 69 00 	lds	r31, 0x0069
     934:	89 81       	ldd	r24, Y+1	; 0x01
     936:	9a 81       	ldd	r25, Y+2	; 0x02
     938:	93 83       	std	Z+3, r25	; 0x03
     93a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     93c:	20 91 6b 00 	lds	r18, 0x006B
     940:	30 91 6c 00 	lds	r19, 0x006C
     944:	89 81       	ldd	r24, Y+1	; 0x01
     946:	9a 81       	ldd	r25, Y+2	; 0x02
     948:	82 17       	cp	r24, r18
     94a:	93 07       	cpc	r25, r19
     94c:	70 f4       	brcc	.+28     	; 0x96a <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     94e:	80 91 97 00 	lds	r24, 0x0097
     952:	90 91 98 00 	lds	r25, 0x0098
     956:	20 91 68 00 	lds	r18, 0x0068
     95a:	30 91 69 00 	lds	r19, 0x0069
     95e:	2e 5f       	subi	r18, 0xFE	; 254
     960:	3f 4f       	sbci	r19, 0xFF	; 255
     962:	b9 01       	movw	r22, r18
     964:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>
     968:	0d c0       	rjmp	.+26     	; 0x984 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     96a:	80 91 95 00 	lds	r24, 0x0095
     96e:	90 91 96 00 	lds	r25, 0x0096
     972:	20 91 68 00 	lds	r18, 0x0068
     976:	30 91 69 00 	lds	r19, 0x0069
     97a:	2e 5f       	subi	r18, 0xFE	; 254
     97c:	3f 4f       	sbci	r19, 0xFF	; 255
     97e:	b9 01       	movw	r22, r18
     980:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>
	}

	if( pxEventList )
     984:	8d 81       	ldd	r24, Y+5	; 0x05
     986:	9e 81       	ldd	r25, Y+6	; 0x06
     988:	00 97       	sbiw	r24, 0x00	; 0
     98a:	61 f0       	breq	.+24     	; 0x9a4 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     98c:	80 91 68 00 	lds	r24, 0x0068
     990:	90 91 69 00 	lds	r25, 0x0069
     994:	9c 01       	movw	r18, r24
     996:	24 5f       	subi	r18, 0xF4	; 244
     998:	3f 4f       	sbci	r19, 0xFF	; 255
     99a:	8d 81       	ldd	r24, Y+5	; 0x05
     99c:	9e 81       	ldd	r25, Y+6	; 0x06
     99e:	b9 01       	movw	r22, r18
     9a0:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>
	}
}
     9a4:	26 96       	adiw	r28, 0x06	; 6
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	f8 94       	cli
     9aa:	de bf       	out	0x3e, r29	; 62
     9ac:	0f be       	out	0x3f, r0	; 63
     9ae:	cd bf       	out	0x3d, r28	; 61
     9b0:	cf 91       	pop	r28
     9b2:	df 91       	pop	r29
     9b4:	08 95       	ret

000009b6 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     9b6:	df 93       	push	r29
     9b8:	cf 93       	push	r28
     9ba:	00 d0       	rcall	.+0      	; 0x9bc <prvCheckPendingReadyList+0x6>
     9bc:	cd b7       	in	r28, 0x3d	; 61
     9be:	de b7       	in	r29, 0x3e	; 62
     9c0:	3a c0       	rjmp	.+116    	; 0xa36 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     9c2:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     9c4:	e0 91 9e 00 	lds	r30, 0x009E
     9c8:	f0 91 9f 00 	lds	r31, 0x009F
     9cc:	86 81       	ldd	r24, Z+6	; 0x06
     9ce:	97 81       	ldd	r25, Z+7	; 0x07
     9d0:	9a 83       	std	Y+2, r25	; 0x02
     9d2:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     9d4:	89 81       	ldd	r24, Y+1	; 0x01
     9d6:	9a 81       	ldd	r25, Y+2	; 0x02
     9d8:	0c 96       	adiw	r24, 0x0c	; 12
     9da:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     9de:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     9e0:	89 81       	ldd	r24, Y+1	; 0x01
     9e2:	9a 81       	ldd	r25, Y+2	; 0x02
     9e4:	02 96       	adiw	r24, 0x02	; 2
     9e6:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     9ea:	e9 81       	ldd	r30, Y+1	; 0x01
     9ec:	fa 81       	ldd	r31, Y+2	; 0x02
     9ee:	96 89       	ldd	r25, Z+22	; 0x16
     9f0:	80 91 6a 00 	lds	r24, 0x006A
     9f4:	89 17       	cp	r24, r25
     9f6:	28 f4       	brcc	.+10     	; 0xa02 <prvCheckPendingReadyList+0x4c>
     9f8:	e9 81       	ldd	r30, Y+1	; 0x01
     9fa:	fa 81       	ldd	r31, Y+2	; 0x02
     9fc:	86 89       	ldd	r24, Z+22	; 0x16
     9fe:	80 93 6a 00 	sts	0x006A, r24
     a02:	e9 81       	ldd	r30, Y+1	; 0x01
     a04:	fa 81       	ldd	r31, Y+2	; 0x02
     a06:	86 89       	ldd	r24, Z+22	; 0x16
     a08:	28 2f       	mov	r18, r24
     a0a:	30 e0       	ldi	r19, 0x00	; 0
     a0c:	c9 01       	movw	r24, r18
     a0e:	88 0f       	add	r24, r24
     a10:	99 1f       	adc	r25, r25
     a12:	88 0f       	add	r24, r24
     a14:	99 1f       	adc	r25, r25
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	82 0f       	add	r24, r18
     a1c:	93 1f       	adc	r25, r19
     a1e:	ac 01       	movw	r20, r24
     a20:	4f 58       	subi	r20, 0x8F	; 143
     a22:	5f 4f       	sbci	r21, 0xFF	; 255
     a24:	89 81       	ldd	r24, Y+1	; 0x01
     a26:	9a 81       	ldd	r25, Y+2	; 0x02
     a28:	9c 01       	movw	r18, r24
     a2a:	2e 5f       	subi	r18, 0xFE	; 254
     a2c:	3f 4f       	sbci	r19, 0xFF	; 255
     a2e:	ca 01       	movw	r24, r20
     a30:	b9 01       	movw	r22, r18
     a32:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     a36:	80 91 99 00 	lds	r24, 0x0099
     a3a:	88 23       	and	r24, r24
     a3c:	09 f0       	breq	.+2      	; 0xa40 <prvCheckPendingReadyList+0x8a>
     a3e:	c1 cf       	rjmp	.-126    	; 0x9c2 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     a40:	0f 90       	pop	r0
     a42:	0f 90       	pop	r0
     a44:	cf 91       	pop	r28
     a46:	df 91       	pop	r29
     a48:	08 95       	ret

00000a4a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     a4a:	df 93       	push	r29
     a4c:	cf 93       	push	r28
     a4e:	00 d0       	rcall	.+0      	; 0xa50 <prvCheckDelayedList+0x6>
     a50:	00 d0       	rcall	.+0      	; 0xa52 <prvCheckDelayedList+0x8>
     a52:	cd b7       	in	r28, 0x3d	; 61
     a54:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     a56:	0e 94 ef 12 	call	0x25de	; 0x25de <xTaskGetTickCount>
     a5a:	20 91 6d 00 	lds	r18, 0x006D
     a5e:	30 91 6e 00 	lds	r19, 0x006E
     a62:	82 1b       	sub	r24, r18
     a64:	93 0b       	sbc	r25, r19
     a66:	90 93 70 00 	sts	0x0070, r25
     a6a:	80 93 6f 00 	sts	0x006F, r24
     a6e:	85 c0       	rjmp	.+266    	; 0xb7a <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     a70:	80 91 6b 00 	lds	r24, 0x006B
     a74:	90 91 6c 00 	lds	r25, 0x006C
     a78:	01 96       	adiw	r24, 0x01	; 1
     a7a:	90 93 6c 00 	sts	0x006C, r25
     a7e:	80 93 6b 00 	sts	0x006B, r24
		xPassedTicks--;
     a82:	80 91 6f 00 	lds	r24, 0x006F
     a86:	90 91 70 00 	lds	r25, 0x0070
     a8a:	01 97       	sbiw	r24, 0x01	; 1
     a8c:	90 93 70 00 	sts	0x0070, r25
     a90:	80 93 6f 00 	sts	0x006F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     a94:	80 91 6b 00 	lds	r24, 0x006B
     a98:	90 91 6c 00 	lds	r25, 0x006C
     a9c:	00 97       	sbiw	r24, 0x00	; 0
     a9e:	09 f0       	breq	.+2      	; 0xaa2 <prvCheckDelayedList+0x58>
     aa0:	64 c0       	rjmp	.+200    	; 0xb6a <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     aa2:	80 91 95 00 	lds	r24, 0x0095
     aa6:	90 91 96 00 	lds	r25, 0x0096
     aaa:	9a 83       	std	Y+2, r25	; 0x02
     aac:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     aae:	80 91 97 00 	lds	r24, 0x0097
     ab2:	90 91 98 00 	lds	r25, 0x0098
     ab6:	90 93 96 00 	sts	0x0096, r25
     aba:	80 93 95 00 	sts	0x0095, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     abe:	89 81       	ldd	r24, Y+1	; 0x01
     ac0:	9a 81       	ldd	r25, Y+2	; 0x02
     ac2:	90 93 98 00 	sts	0x0098, r25
     ac6:	80 93 97 00 	sts	0x0097, r24
     aca:	4f c0       	rjmp	.+158    	; 0xb6a <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     acc:	e0 91 95 00 	lds	r30, 0x0095
     ad0:	f0 91 96 00 	lds	r31, 0x0096
     ad4:	05 80       	ldd	r0, Z+5	; 0x05
     ad6:	f6 81       	ldd	r31, Z+6	; 0x06
     ad8:	e0 2d       	mov	r30, r0
     ada:	86 81       	ldd	r24, Z+6	; 0x06
     adc:	97 81       	ldd	r25, Z+7	; 0x07
     ade:	9c 83       	std	Y+4, r25	; 0x04
     ae0:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     ae2:	eb 81       	ldd	r30, Y+3	; 0x03
     ae4:	fc 81       	ldd	r31, Y+4	; 0x04
     ae6:	22 81       	ldd	r18, Z+2	; 0x02
     ae8:	33 81       	ldd	r19, Z+3	; 0x03
     aea:	80 91 6b 00 	lds	r24, 0x006B
     aee:	90 91 6c 00 	lds	r25, 0x006C
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	08 f4       	brcc	.+2      	; 0xafa <prvCheckDelayedList+0xb0>
     af8:	40 c0       	rjmp	.+128    	; 0xb7a <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     afa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     afc:	8b 81       	ldd	r24, Y+3	; 0x03
     afe:	9c 81       	ldd	r25, Y+4	; 0x04
     b00:	02 96       	adiw	r24, 0x02	; 2
     b02:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     b06:	eb 81       	ldd	r30, Y+3	; 0x03
     b08:	fc 81       	ldd	r31, Y+4	; 0x04
     b0a:	84 89       	ldd	r24, Z+20	; 0x14
     b0c:	95 89       	ldd	r25, Z+21	; 0x15
     b0e:	00 97       	sbiw	r24, 0x00	; 0
     b10:	29 f0       	breq	.+10     	; 0xb1c <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     b12:	8b 81       	ldd	r24, Y+3	; 0x03
     b14:	9c 81       	ldd	r25, Y+4	; 0x04
     b16:	0c 96       	adiw	r24, 0x0c	; 12
     b18:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     b1c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     b1e:	eb 81       	ldd	r30, Y+3	; 0x03
     b20:	fc 81       	ldd	r31, Y+4	; 0x04
     b22:	96 89       	ldd	r25, Z+22	; 0x16
     b24:	80 91 6a 00 	lds	r24, 0x006A
     b28:	89 17       	cp	r24, r25
     b2a:	28 f4       	brcc	.+10     	; 0xb36 <prvCheckDelayedList+0xec>
     b2c:	eb 81       	ldd	r30, Y+3	; 0x03
     b2e:	fc 81       	ldd	r31, Y+4	; 0x04
     b30:	86 89       	ldd	r24, Z+22	; 0x16
     b32:	80 93 6a 00 	sts	0x006A, r24
     b36:	eb 81       	ldd	r30, Y+3	; 0x03
     b38:	fc 81       	ldd	r31, Y+4	; 0x04
     b3a:	86 89       	ldd	r24, Z+22	; 0x16
     b3c:	28 2f       	mov	r18, r24
     b3e:	30 e0       	ldi	r19, 0x00	; 0
     b40:	c9 01       	movw	r24, r18
     b42:	88 0f       	add	r24, r24
     b44:	99 1f       	adc	r25, r25
     b46:	88 0f       	add	r24, r24
     b48:	99 1f       	adc	r25, r25
     b4a:	88 0f       	add	r24, r24
     b4c:	99 1f       	adc	r25, r25
     b4e:	82 0f       	add	r24, r18
     b50:	93 1f       	adc	r25, r19
     b52:	ac 01       	movw	r20, r24
     b54:	4f 58       	subi	r20, 0x8F	; 143
     b56:	5f 4f       	sbci	r21, 0xFF	; 255
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	9c 01       	movw	r18, r24
     b5e:	2e 5f       	subi	r18, 0xFE	; 254
     b60:	3f 4f       	sbci	r19, 0xFF	; 255
     b62:	ca 01       	movw	r24, r20
     b64:	b9 01       	movw	r22, r18
     b66:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     b6a:	e0 91 95 00 	lds	r30, 0x0095
     b6e:	f0 91 96 00 	lds	r31, 0x0096
     b72:	80 81       	ld	r24, Z
     b74:	88 23       	and	r24, r24
     b76:	09 f0       	breq	.+2      	; 0xb7a <prvCheckDelayedList+0x130>
     b78:	a9 cf       	rjmp	.-174    	; 0xacc <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     b7a:	80 91 6f 00 	lds	r24, 0x006F
     b7e:	90 91 70 00 	lds	r25, 0x0070
     b82:	00 97       	sbiw	r24, 0x00	; 0
     b84:	09 f0       	breq	.+2      	; 0xb88 <prvCheckDelayedList+0x13e>
     b86:	74 cf       	rjmp	.-280    	; 0xa70 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     b88:	80 91 6b 00 	lds	r24, 0x006B
     b8c:	90 91 6c 00 	lds	r25, 0x006C
     b90:	90 93 6e 00 	sts	0x006E, r25
     b94:	80 93 6d 00 	sts	0x006D, r24
}
     b98:	0f 90       	pop	r0
     b9a:	0f 90       	pop	r0
     b9c:	0f 90       	pop	r0
     b9e:	0f 90       	pop	r0
     ba0:	cf 91       	pop	r28
     ba2:	df 91       	pop	r29
     ba4:	08 95       	ret

00000ba6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     ba6:	df 93       	push	r29
     ba8:	cf 93       	push	r28
     baa:	00 d0       	rcall	.+0      	; 0xbac <vCoRoutineSchedule+0x6>
     bac:	cd b7       	in	r28, 0x3d	; 61
     bae:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     bb0:	0e 94 db 04 	call	0x9b6	; 0x9b6 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     bb4:	0e 94 25 05 	call	0xa4a	; 0xa4a <prvCheckDelayedList>
     bb8:	0a c0       	rjmp	.+20     	; 0xbce <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     bba:	80 91 6a 00 	lds	r24, 0x006A
     bbe:	88 23       	and	r24, r24
     bc0:	09 f4       	brne	.+2      	; 0xbc4 <vCoRoutineSchedule+0x1e>
     bc2:	66 c0       	rjmp	.+204    	; 0xc90 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     bc4:	80 91 6a 00 	lds	r24, 0x006A
     bc8:	81 50       	subi	r24, 0x01	; 1
     bca:	80 93 6a 00 	sts	0x006A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     bce:	80 91 6a 00 	lds	r24, 0x006A
     bd2:	28 2f       	mov	r18, r24
     bd4:	30 e0       	ldi	r19, 0x00	; 0
     bd6:	c9 01       	movw	r24, r18
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	88 0f       	add	r24, r24
     bde:	99 1f       	adc	r25, r25
     be0:	88 0f       	add	r24, r24
     be2:	99 1f       	adc	r25, r25
     be4:	82 0f       	add	r24, r18
     be6:	93 1f       	adc	r25, r19
     be8:	fc 01       	movw	r30, r24
     bea:	ef 58       	subi	r30, 0x8F	; 143
     bec:	ff 4f       	sbci	r31, 0xFF	; 255
     bee:	80 81       	ld	r24, Z
     bf0:	88 23       	and	r24, r24
     bf2:	19 f3       	breq	.-58     	; 0xbba <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     bf4:	80 91 6a 00 	lds	r24, 0x006A
     bf8:	28 2f       	mov	r18, r24
     bfa:	30 e0       	ldi	r19, 0x00	; 0
     bfc:	c9 01       	movw	r24, r18
     bfe:	88 0f       	add	r24, r24
     c00:	99 1f       	adc	r25, r25
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	88 0f       	add	r24, r24
     c08:	99 1f       	adc	r25, r25
     c0a:	82 0f       	add	r24, r18
     c0c:	93 1f       	adc	r25, r19
     c0e:	8f 58       	subi	r24, 0x8F	; 143
     c10:	9f 4f       	sbci	r25, 0xFF	; 255
     c12:	9a 83       	std	Y+2, r25	; 0x02
     c14:	89 83       	std	Y+1, r24	; 0x01
     c16:	e9 81       	ldd	r30, Y+1	; 0x01
     c18:	fa 81       	ldd	r31, Y+2	; 0x02
     c1a:	01 80       	ldd	r0, Z+1	; 0x01
     c1c:	f2 81       	ldd	r31, Z+2	; 0x02
     c1e:	e0 2d       	mov	r30, r0
     c20:	82 81       	ldd	r24, Z+2	; 0x02
     c22:	93 81       	ldd	r25, Z+3	; 0x03
     c24:	e9 81       	ldd	r30, Y+1	; 0x01
     c26:	fa 81       	ldd	r31, Y+2	; 0x02
     c28:	92 83       	std	Z+2, r25	; 0x02
     c2a:	81 83       	std	Z+1, r24	; 0x01
     c2c:	e9 81       	ldd	r30, Y+1	; 0x01
     c2e:	fa 81       	ldd	r31, Y+2	; 0x02
     c30:	21 81       	ldd	r18, Z+1	; 0x01
     c32:	32 81       	ldd	r19, Z+2	; 0x02
     c34:	89 81       	ldd	r24, Y+1	; 0x01
     c36:	9a 81       	ldd	r25, Y+2	; 0x02
     c38:	03 96       	adiw	r24, 0x03	; 3
     c3a:	28 17       	cp	r18, r24
     c3c:	39 07       	cpc	r19, r25
     c3e:	59 f4       	brne	.+22     	; 0xc56 <vCoRoutineSchedule+0xb0>
     c40:	e9 81       	ldd	r30, Y+1	; 0x01
     c42:	fa 81       	ldd	r31, Y+2	; 0x02
     c44:	01 80       	ldd	r0, Z+1	; 0x01
     c46:	f2 81       	ldd	r31, Z+2	; 0x02
     c48:	e0 2d       	mov	r30, r0
     c4a:	82 81       	ldd	r24, Z+2	; 0x02
     c4c:	93 81       	ldd	r25, Z+3	; 0x03
     c4e:	e9 81       	ldd	r30, Y+1	; 0x01
     c50:	fa 81       	ldd	r31, Y+2	; 0x02
     c52:	92 83       	std	Z+2, r25	; 0x02
     c54:	81 83       	std	Z+1, r24	; 0x01
     c56:	e9 81       	ldd	r30, Y+1	; 0x01
     c58:	fa 81       	ldd	r31, Y+2	; 0x02
     c5a:	01 80       	ldd	r0, Z+1	; 0x01
     c5c:	f2 81       	ldd	r31, Z+2	; 0x02
     c5e:	e0 2d       	mov	r30, r0
     c60:	86 81       	ldd	r24, Z+6	; 0x06
     c62:	97 81       	ldd	r25, Z+7	; 0x07
     c64:	90 93 69 00 	sts	0x0069, r25
     c68:	80 93 68 00 	sts	0x0068, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     c6c:	e0 91 68 00 	lds	r30, 0x0068
     c70:	f0 91 69 00 	lds	r31, 0x0069
     c74:	40 81       	ld	r20, Z
     c76:	51 81       	ldd	r21, Z+1	; 0x01
     c78:	80 91 68 00 	lds	r24, 0x0068
     c7c:	90 91 69 00 	lds	r25, 0x0069
     c80:	e0 91 68 00 	lds	r30, 0x0068
     c84:	f0 91 69 00 	lds	r31, 0x0069
     c88:	27 89       	ldd	r18, Z+23	; 0x17
     c8a:	62 2f       	mov	r22, r18
     c8c:	fa 01       	movw	r30, r20
     c8e:	09 95       	icall

	return;
}
     c90:	0f 90       	pop	r0
     c92:	0f 90       	pop	r0
     c94:	cf 91       	pop	r28
     c96:	df 91       	pop	r29
     c98:	08 95       	ret

00000c9a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     c9a:	df 93       	push	r29
     c9c:	cf 93       	push	r28
     c9e:	0f 92       	push	r0
     ca0:	cd b7       	in	r28, 0x3d	; 61
     ca2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     ca4:	19 82       	std	Y+1, r1	; 0x01
     ca6:	13 c0       	rjmp	.+38     	; 0xcce <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     ca8:	89 81       	ldd	r24, Y+1	; 0x01
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	c9 01       	movw	r24, r18
     cb0:	88 0f       	add	r24, r24
     cb2:	99 1f       	adc	r25, r25
     cb4:	88 0f       	add	r24, r24
     cb6:	99 1f       	adc	r25, r25
     cb8:	88 0f       	add	r24, r24
     cba:	99 1f       	adc	r25, r25
     cbc:	82 0f       	add	r24, r18
     cbe:	93 1f       	adc	r25, r19
     cc0:	8f 58       	subi	r24, 0x8F	; 143
     cc2:	9f 4f       	sbci	r25, 0xFF	; 255
     cc4:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     cc8:	89 81       	ldd	r24, Y+1	; 0x01
     cca:	8f 5f       	subi	r24, 0xFF	; 255
     ccc:	89 83       	std	Y+1, r24	; 0x01
     cce:	89 81       	ldd	r24, Y+1	; 0x01
     cd0:	82 30       	cpi	r24, 0x02	; 2
     cd2:	50 f3       	brcs	.-44     	; 0xca8 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     cd4:	83 e8       	ldi	r24, 0x83	; 131
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     cdc:	8c e8       	ldi	r24, 0x8C	; 140
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     ce4:	89 e9       	ldi	r24, 0x99	; 153
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     cec:	83 e8       	ldi	r24, 0x83	; 131
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	90 93 96 00 	sts	0x0096, r25
     cf4:	80 93 95 00 	sts	0x0095, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     cf8:	8c e8       	ldi	r24, 0x8C	; 140
     cfa:	90 e0       	ldi	r25, 0x00	; 0
     cfc:	90 93 98 00 	sts	0x0098, r25
     d00:	80 93 97 00 	sts	0x0097, r24
}
     d04:	0f 90       	pop	r0
     d06:	cf 91       	pop	r28
     d08:	df 91       	pop	r29
     d0a:	08 95       	ret

00000d0c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     d0c:	df 93       	push	r29
     d0e:	cf 93       	push	r28
     d10:	00 d0       	rcall	.+0      	; 0xd12 <xCoRoutineRemoveFromEventList+0x6>
     d12:	00 d0       	rcall	.+0      	; 0xd14 <xCoRoutineRemoveFromEventList+0x8>
     d14:	0f 92       	push	r0
     d16:	cd b7       	in	r28, 0x3d	; 61
     d18:	de b7       	in	r29, 0x3e	; 62
     d1a:	9d 83       	std	Y+5, r25	; 0x05
     d1c:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     d1e:	ec 81       	ldd	r30, Y+4	; 0x04
     d20:	fd 81       	ldd	r31, Y+5	; 0x05
     d22:	05 80       	ldd	r0, Z+5	; 0x05
     d24:	f6 81       	ldd	r31, Z+6	; 0x06
     d26:	e0 2d       	mov	r30, r0
     d28:	86 81       	ldd	r24, Z+6	; 0x06
     d2a:	97 81       	ldd	r25, Z+7	; 0x07
     d2c:	9b 83       	std	Y+3, r25	; 0x03
     d2e:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	0c 96       	adiw	r24, 0x0c	; 12
     d36:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     d3a:	8a 81       	ldd	r24, Y+2	; 0x02
     d3c:	9b 81       	ldd	r25, Y+3	; 0x03
     d3e:	9c 01       	movw	r18, r24
     d40:	24 5f       	subi	r18, 0xF4	; 244
     d42:	3f 4f       	sbci	r19, 0xFF	; 255
     d44:	89 e9       	ldi	r24, 0x99	; 153
     d46:	90 e0       	ldi	r25, 0x00	; 0
     d48:	b9 01       	movw	r22, r18
     d4a:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     d4e:	ea 81       	ldd	r30, Y+2	; 0x02
     d50:	fb 81       	ldd	r31, Y+3	; 0x03
     d52:	96 89       	ldd	r25, Z+22	; 0x16
     d54:	e0 91 68 00 	lds	r30, 0x0068
     d58:	f0 91 69 00 	lds	r31, 0x0069
     d5c:	86 89       	ldd	r24, Z+22	; 0x16
     d5e:	98 17       	cp	r25, r24
     d60:	18 f0       	brcs	.+6      	; 0xd68 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     d62:	81 e0       	ldi	r24, 0x01	; 1
     d64:	89 83       	std	Y+1, r24	; 0x01
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     d68:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     d6a:	89 81       	ldd	r24, Y+1	; 0x01
}
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	cf 91       	pop	r28
     d78:	df 91       	pop	r29
     d7a:	08 95       	ret

00000d7c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d7c:	df 93       	push	r29
     d7e:	cf 93       	push	r28
     d80:	00 d0       	rcall	.+0      	; 0xd82 <pvPortMalloc+0x6>
     d82:	00 d0       	rcall	.+0      	; 0xd84 <pvPortMalloc+0x8>
     d84:	cd b7       	in	r28, 0x3d	; 61
     d86:	de b7       	in	r29, 0x3e	; 62
     d88:	9c 83       	std	Y+4, r25	; 0x04
     d8a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     d8c:	1a 82       	std	Y+2, r1	; 0x02
     d8e:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     d90:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     d94:	80 91 a2 00 	lds	r24, 0x00A2
     d98:	90 91 a3 00 	lds	r25, 0x00A3
     d9c:	2b 81       	ldd	r18, Y+3	; 0x03
     d9e:	3c 81       	ldd	r19, Y+4	; 0x04
     da0:	82 0f       	add	r24, r18
     da2:	93 1f       	adc	r25, r19
     da4:	22 e0       	ldi	r18, 0x02	; 2
     da6:	88 35       	cpi	r24, 0x58	; 88
     da8:	92 07       	cpc	r25, r18
     daa:	18 f5       	brcc	.+70     	; 0xdf2 <pvPortMalloc+0x76>
     dac:	20 91 a2 00 	lds	r18, 0x00A2
     db0:	30 91 a3 00 	lds	r19, 0x00A3
     db4:	8b 81       	ldd	r24, Y+3	; 0x03
     db6:	9c 81       	ldd	r25, Y+4	; 0x04
     db8:	28 0f       	add	r18, r24
     dba:	39 1f       	adc	r19, r25
     dbc:	80 91 a2 00 	lds	r24, 0x00A2
     dc0:	90 91 a3 00 	lds	r25, 0x00A3
     dc4:	82 17       	cp	r24, r18
     dc6:	93 07       	cpc	r25, r19
     dc8:	a0 f4       	brcc	.+40     	; 0xdf2 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     dca:	80 91 a2 00 	lds	r24, 0x00A2
     dce:	90 91 a3 00 	lds	r25, 0x00A3
     dd2:	8c 55       	subi	r24, 0x5C	; 92
     dd4:	9f 4f       	sbci	r25, 0xFF	; 255
     dd6:	9a 83       	std	Y+2, r25	; 0x02
     dd8:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     dda:	20 91 a2 00 	lds	r18, 0x00A2
     dde:	30 91 a3 00 	lds	r19, 0x00A3
     de2:	8b 81       	ldd	r24, Y+3	; 0x03
     de4:	9c 81       	ldd	r25, Y+4	; 0x04
     de6:	82 0f       	add	r24, r18
     de8:	93 1f       	adc	r25, r19
     dea:	90 93 a3 00 	sts	0x00A3, r25
     dee:	80 93 a2 00 	sts	0x00A2, r24
		}	
	}
	xTaskResumeAll();
     df2:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     df6:	89 81       	ldd	r24, Y+1	; 0x01
     df8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     dfa:	0f 90       	pop	r0
     dfc:	0f 90       	pop	r0
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	cf 91       	pop	r28
     e04:	df 91       	pop	r29
     e06:	08 95       	ret

00000e08 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     e08:	df 93       	push	r29
     e0a:	cf 93       	push	r28
     e0c:	00 d0       	rcall	.+0      	; 0xe0e <vPortFree+0x6>
     e0e:	cd b7       	in	r28, 0x3d	; 61
     e10:	de b7       	in	r29, 0x3e	; 62
     e12:	9a 83       	std	Y+2, r25	; 0x02
     e14:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     e16:	0f 90       	pop	r0
     e18:	0f 90       	pop	r0
     e1a:	cf 91       	pop	r28
     e1c:	df 91       	pop	r29
     e1e:	08 95       	ret

00000e20 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e20:	df 93       	push	r29
     e22:	cf 93       	push	r28
     e24:	cd b7       	in	r28, 0x3d	; 61
     e26:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     e28:	10 92 a3 00 	sts	0x00A3, r1
     e2c:	10 92 a2 00 	sts	0x00A2, r1
}
     e30:	cf 91       	pop	r28
     e32:	df 91       	pop	r29
     e34:	08 95       	ret

00000e36 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     e36:	df 93       	push	r29
     e38:	cf 93       	push	r28
     e3a:	cd b7       	in	r28, 0x3d	; 61
     e3c:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     e3e:	20 91 a2 00 	lds	r18, 0x00A2
     e42:	30 91 a3 00 	lds	r19, 0x00A3
     e46:	88 e5       	ldi	r24, 0x58	; 88
     e48:	92 e0       	ldi	r25, 0x02	; 2
     e4a:	82 1b       	sub	r24, r18
     e4c:	93 0b       	sbc	r25, r19
}
     e4e:	cf 91       	pop	r28
     e50:	df 91       	pop	r29
     e52:	08 95       	ret

00000e54 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     e54:	df 93       	push	r29
     e56:	cf 93       	push	r28
     e58:	00 d0       	rcall	.+0      	; 0xe5a <vListInitialise+0x6>
     e5a:	cd b7       	in	r28, 0x3d	; 61
     e5c:	de b7       	in	r29, 0x3e	; 62
     e5e:	9a 83       	std	Y+2, r25	; 0x02
     e60:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	9a 81       	ldd	r25, Y+2	; 0x02
     e66:	03 96       	adiw	r24, 0x03	; 3
     e68:	e9 81       	ldd	r30, Y+1	; 0x01
     e6a:	fa 81       	ldd	r31, Y+2	; 0x02
     e6c:	92 83       	std	Z+2, r25	; 0x02
     e6e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e70:	e9 81       	ldd	r30, Y+1	; 0x01
     e72:	fa 81       	ldd	r31, Y+2	; 0x02
     e74:	8f ef       	ldi	r24, 0xFF	; 255
     e76:	9f ef       	ldi	r25, 0xFF	; 255
     e78:	94 83       	std	Z+4, r25	; 0x04
     e7a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     e7c:	89 81       	ldd	r24, Y+1	; 0x01
     e7e:	9a 81       	ldd	r25, Y+2	; 0x02
     e80:	03 96       	adiw	r24, 0x03	; 3
     e82:	e9 81       	ldd	r30, Y+1	; 0x01
     e84:	fa 81       	ldd	r31, Y+2	; 0x02
     e86:	96 83       	std	Z+6, r25	; 0x06
     e88:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     e8a:	89 81       	ldd	r24, Y+1	; 0x01
     e8c:	9a 81       	ldd	r25, Y+2	; 0x02
     e8e:	03 96       	adiw	r24, 0x03	; 3
     e90:	e9 81       	ldd	r30, Y+1	; 0x01
     e92:	fa 81       	ldd	r31, Y+2	; 0x02
     e94:	90 87       	std	Z+8, r25	; 0x08
     e96:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     e98:	e9 81       	ldd	r30, Y+1	; 0x01
     e9a:	fa 81       	ldd	r31, Y+2	; 0x02
     e9c:	10 82       	st	Z, r1
}
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	cf 91       	pop	r28
     ea4:	df 91       	pop	r29
     ea6:	08 95       	ret

00000ea8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     ea8:	df 93       	push	r29
     eaa:	cf 93       	push	r28
     eac:	00 d0       	rcall	.+0      	; 0xeae <vListInitialiseItem+0x6>
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	9a 83       	std	Y+2, r25	; 0x02
     eb4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     eb6:	e9 81       	ldd	r30, Y+1	; 0x01
     eb8:	fa 81       	ldd	r31, Y+2	; 0x02
     eba:	11 86       	std	Z+9, r1	; 0x09
     ebc:	10 86       	std	Z+8, r1	; 0x08
}
     ebe:	0f 90       	pop	r0
     ec0:	0f 90       	pop	r0
     ec2:	cf 91       	pop	r28
     ec4:	df 91       	pop	r29
     ec6:	08 95       	ret

00000ec8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     ec8:	df 93       	push	r29
     eca:	cf 93       	push	r28
     ecc:	00 d0       	rcall	.+0      	; 0xece <vListInsertEnd+0x6>
     ece:	00 d0       	rcall	.+0      	; 0xed0 <vListInsertEnd+0x8>
     ed0:	00 d0       	rcall	.+0      	; 0xed2 <vListInsertEnd+0xa>
     ed2:	cd b7       	in	r28, 0x3d	; 61
     ed4:	de b7       	in	r29, 0x3e	; 62
     ed6:	9c 83       	std	Y+4, r25	; 0x04
     ed8:	8b 83       	std	Y+3, r24	; 0x03
     eda:	7e 83       	std	Y+6, r23	; 0x06
     edc:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     ede:	eb 81       	ldd	r30, Y+3	; 0x03
     ee0:	fc 81       	ldd	r31, Y+4	; 0x04
     ee2:	81 81       	ldd	r24, Z+1	; 0x01
     ee4:	92 81       	ldd	r25, Z+2	; 0x02
     ee6:	9a 83       	std	Y+2, r25	; 0x02
     ee8:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     eea:	e9 81       	ldd	r30, Y+1	; 0x01
     eec:	fa 81       	ldd	r31, Y+2	; 0x02
     eee:	82 81       	ldd	r24, Z+2	; 0x02
     ef0:	93 81       	ldd	r25, Z+3	; 0x03
     ef2:	ed 81       	ldd	r30, Y+5	; 0x05
     ef4:	fe 81       	ldd	r31, Y+6	; 0x06
     ef6:	93 83       	std	Z+3, r25	; 0x03
     ef8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     efa:	eb 81       	ldd	r30, Y+3	; 0x03
     efc:	fc 81       	ldd	r31, Y+4	; 0x04
     efe:	81 81       	ldd	r24, Z+1	; 0x01
     f00:	92 81       	ldd	r25, Z+2	; 0x02
     f02:	ed 81       	ldd	r30, Y+5	; 0x05
     f04:	fe 81       	ldd	r31, Y+6	; 0x06
     f06:	95 83       	std	Z+5, r25	; 0x05
     f08:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     f0a:	e9 81       	ldd	r30, Y+1	; 0x01
     f0c:	fa 81       	ldd	r31, Y+2	; 0x02
     f0e:	02 80       	ldd	r0, Z+2	; 0x02
     f10:	f3 81       	ldd	r31, Z+3	; 0x03
     f12:	e0 2d       	mov	r30, r0
     f14:	8d 81       	ldd	r24, Y+5	; 0x05
     f16:	9e 81       	ldd	r25, Y+6	; 0x06
     f18:	95 83       	std	Z+5, r25	; 0x05
     f1a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     f1c:	8d 81       	ldd	r24, Y+5	; 0x05
     f1e:	9e 81       	ldd	r25, Y+6	; 0x06
     f20:	e9 81       	ldd	r30, Y+1	; 0x01
     f22:	fa 81       	ldd	r31, Y+2	; 0x02
     f24:	93 83       	std	Z+3, r25	; 0x03
     f26:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     f28:	8d 81       	ldd	r24, Y+5	; 0x05
     f2a:	9e 81       	ldd	r25, Y+6	; 0x06
     f2c:	eb 81       	ldd	r30, Y+3	; 0x03
     f2e:	fc 81       	ldd	r31, Y+4	; 0x04
     f30:	92 83       	std	Z+2, r25	; 0x02
     f32:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     f34:	ed 81       	ldd	r30, Y+5	; 0x05
     f36:	fe 81       	ldd	r31, Y+6	; 0x06
     f38:	8b 81       	ldd	r24, Y+3	; 0x03
     f3a:	9c 81       	ldd	r25, Y+4	; 0x04
     f3c:	91 87       	std	Z+9, r25	; 0x09
     f3e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     f40:	eb 81       	ldd	r30, Y+3	; 0x03
     f42:	fc 81       	ldd	r31, Y+4	; 0x04
     f44:	80 81       	ld	r24, Z
     f46:	8f 5f       	subi	r24, 0xFF	; 255
     f48:	eb 81       	ldd	r30, Y+3	; 0x03
     f4a:	fc 81       	ldd	r31, Y+4	; 0x04
     f4c:	80 83       	st	Z, r24
}
     f4e:	26 96       	adiw	r28, 0x06	; 6
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	f8 94       	cli
     f54:	de bf       	out	0x3e, r29	; 62
     f56:	0f be       	out	0x3f, r0	; 63
     f58:	cd bf       	out	0x3d, r28	; 61
     f5a:	cf 91       	pop	r28
     f5c:	df 91       	pop	r29
     f5e:	08 95       	ret

00000f60 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     f60:	df 93       	push	r29
     f62:	cf 93       	push	r28
     f64:	cd b7       	in	r28, 0x3d	; 61
     f66:	de b7       	in	r29, 0x3e	; 62
     f68:	28 97       	sbiw	r28, 0x08	; 8
     f6a:	0f b6       	in	r0, 0x3f	; 63
     f6c:	f8 94       	cli
     f6e:	de bf       	out	0x3e, r29	; 62
     f70:	0f be       	out	0x3f, r0	; 63
     f72:	cd bf       	out	0x3d, r28	; 61
     f74:	9e 83       	std	Y+6, r25	; 0x06
     f76:	8d 83       	std	Y+5, r24	; 0x05
     f78:	78 87       	std	Y+8, r23	; 0x08
     f7a:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     f7c:	ef 81       	ldd	r30, Y+7	; 0x07
     f7e:	f8 85       	ldd	r31, Y+8	; 0x08
     f80:	80 81       	ld	r24, Z
     f82:	91 81       	ldd	r25, Z+1	; 0x01
     f84:	9a 83       	std	Y+2, r25	; 0x02
     f86:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     f88:	89 81       	ldd	r24, Y+1	; 0x01
     f8a:	9a 81       	ldd	r25, Y+2	; 0x02
     f8c:	2f ef       	ldi	r18, 0xFF	; 255
     f8e:	8f 3f       	cpi	r24, 0xFF	; 255
     f90:	92 07       	cpc	r25, r18
     f92:	39 f4       	brne	.+14     	; 0xfa2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     f94:	ed 81       	ldd	r30, Y+5	; 0x05
     f96:	fe 81       	ldd	r31, Y+6	; 0x06
     f98:	87 81       	ldd	r24, Z+7	; 0x07
     f9a:	90 85       	ldd	r25, Z+8	; 0x08
     f9c:	9c 83       	std	Y+4, r25	; 0x04
     f9e:	8b 83       	std	Y+3, r24	; 0x03
     fa0:	18 c0       	rjmp	.+48     	; 0xfd2 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     fa2:	8d 81       	ldd	r24, Y+5	; 0x05
     fa4:	9e 81       	ldd	r25, Y+6	; 0x06
     fa6:	03 96       	adiw	r24, 0x03	; 3
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03
     fac:	06 c0       	rjmp	.+12     	; 0xfba <vListInsert+0x5a>
     fae:	eb 81       	ldd	r30, Y+3	; 0x03
     fb0:	fc 81       	ldd	r31, Y+4	; 0x04
     fb2:	82 81       	ldd	r24, Z+2	; 0x02
     fb4:	93 81       	ldd	r25, Z+3	; 0x03
     fb6:	9c 83       	std	Y+4, r25	; 0x04
     fb8:	8b 83       	std	Y+3, r24	; 0x03
     fba:	eb 81       	ldd	r30, Y+3	; 0x03
     fbc:	fc 81       	ldd	r31, Y+4	; 0x04
     fbe:	02 80       	ldd	r0, Z+2	; 0x02
     fc0:	f3 81       	ldd	r31, Z+3	; 0x03
     fc2:	e0 2d       	mov	r30, r0
     fc4:	20 81       	ld	r18, Z
     fc6:	31 81       	ldd	r19, Z+1	; 0x01
     fc8:	89 81       	ldd	r24, Y+1	; 0x01
     fca:	9a 81       	ldd	r25, Y+2	; 0x02
     fcc:	82 17       	cp	r24, r18
     fce:	93 07       	cpc	r25, r19
     fd0:	70 f7       	brcc	.-36     	; 0xfae <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     fd2:	eb 81       	ldd	r30, Y+3	; 0x03
     fd4:	fc 81       	ldd	r31, Y+4	; 0x04
     fd6:	82 81       	ldd	r24, Z+2	; 0x02
     fd8:	93 81       	ldd	r25, Z+3	; 0x03
     fda:	ef 81       	ldd	r30, Y+7	; 0x07
     fdc:	f8 85       	ldd	r31, Y+8	; 0x08
     fde:	93 83       	std	Z+3, r25	; 0x03
     fe0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     fe2:	ef 81       	ldd	r30, Y+7	; 0x07
     fe4:	f8 85       	ldd	r31, Y+8	; 0x08
     fe6:	02 80       	ldd	r0, Z+2	; 0x02
     fe8:	f3 81       	ldd	r31, Z+3	; 0x03
     fea:	e0 2d       	mov	r30, r0
     fec:	8f 81       	ldd	r24, Y+7	; 0x07
     fee:	98 85       	ldd	r25, Y+8	; 0x08
     ff0:	95 83       	std	Z+5, r25	; 0x05
     ff2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ff4:	ef 81       	ldd	r30, Y+7	; 0x07
     ff6:	f8 85       	ldd	r31, Y+8	; 0x08
     ff8:	8b 81       	ldd	r24, Y+3	; 0x03
     ffa:	9c 81       	ldd	r25, Y+4	; 0x04
     ffc:	95 83       	std	Z+5, r25	; 0x05
     ffe:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1000:	8f 81       	ldd	r24, Y+7	; 0x07
    1002:	98 85       	ldd	r25, Y+8	; 0x08
    1004:	eb 81       	ldd	r30, Y+3	; 0x03
    1006:	fc 81       	ldd	r31, Y+4	; 0x04
    1008:	93 83       	std	Z+3, r25	; 0x03
    100a:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    100c:	ef 81       	ldd	r30, Y+7	; 0x07
    100e:	f8 85       	ldd	r31, Y+8	; 0x08
    1010:	8d 81       	ldd	r24, Y+5	; 0x05
    1012:	9e 81       	ldd	r25, Y+6	; 0x06
    1014:	91 87       	std	Z+9, r25	; 0x09
    1016:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1018:	ed 81       	ldd	r30, Y+5	; 0x05
    101a:	fe 81       	ldd	r31, Y+6	; 0x06
    101c:	80 81       	ld	r24, Z
    101e:	8f 5f       	subi	r24, 0xFF	; 255
    1020:	ed 81       	ldd	r30, Y+5	; 0x05
    1022:	fe 81       	ldd	r31, Y+6	; 0x06
    1024:	80 83       	st	Z, r24
}
    1026:	28 96       	adiw	r28, 0x08	; 8
    1028:	0f b6       	in	r0, 0x3f	; 63
    102a:	f8 94       	cli
    102c:	de bf       	out	0x3e, r29	; 62
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	cd bf       	out	0x3d, r28	; 61
    1032:	cf 91       	pop	r28
    1034:	df 91       	pop	r29
    1036:	08 95       	ret

00001038 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1038:	df 93       	push	r29
    103a:	cf 93       	push	r28
    103c:	00 d0       	rcall	.+0      	; 0x103e <vListRemove+0x6>
    103e:	00 d0       	rcall	.+0      	; 0x1040 <vListRemove+0x8>
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	9c 83       	std	Y+4, r25	; 0x04
    1046:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1048:	eb 81       	ldd	r30, Y+3	; 0x03
    104a:	fc 81       	ldd	r31, Y+4	; 0x04
    104c:	a2 81       	ldd	r26, Z+2	; 0x02
    104e:	b3 81       	ldd	r27, Z+3	; 0x03
    1050:	eb 81       	ldd	r30, Y+3	; 0x03
    1052:	fc 81       	ldd	r31, Y+4	; 0x04
    1054:	84 81       	ldd	r24, Z+4	; 0x04
    1056:	95 81       	ldd	r25, Z+5	; 0x05
    1058:	15 96       	adiw	r26, 0x05	; 5
    105a:	9c 93       	st	X, r25
    105c:	8e 93       	st	-X, r24
    105e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1060:	eb 81       	ldd	r30, Y+3	; 0x03
    1062:	fc 81       	ldd	r31, Y+4	; 0x04
    1064:	a4 81       	ldd	r26, Z+4	; 0x04
    1066:	b5 81       	ldd	r27, Z+5	; 0x05
    1068:	eb 81       	ldd	r30, Y+3	; 0x03
    106a:	fc 81       	ldd	r31, Y+4	; 0x04
    106c:	82 81       	ldd	r24, Z+2	; 0x02
    106e:	93 81       	ldd	r25, Z+3	; 0x03
    1070:	13 96       	adiw	r26, 0x03	; 3
    1072:	9c 93       	st	X, r25
    1074:	8e 93       	st	-X, r24
    1076:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1078:	eb 81       	ldd	r30, Y+3	; 0x03
    107a:	fc 81       	ldd	r31, Y+4	; 0x04
    107c:	80 85       	ldd	r24, Z+8	; 0x08
    107e:	91 85       	ldd	r25, Z+9	; 0x09
    1080:	9a 83       	std	Y+2, r25	; 0x02
    1082:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1084:	e9 81       	ldd	r30, Y+1	; 0x01
    1086:	fa 81       	ldd	r31, Y+2	; 0x02
    1088:	21 81       	ldd	r18, Z+1	; 0x01
    108a:	32 81       	ldd	r19, Z+2	; 0x02
    108c:	8b 81       	ldd	r24, Y+3	; 0x03
    108e:	9c 81       	ldd	r25, Y+4	; 0x04
    1090:	28 17       	cp	r18, r24
    1092:	39 07       	cpc	r19, r25
    1094:	41 f4       	brne	.+16     	; 0x10a6 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1096:	eb 81       	ldd	r30, Y+3	; 0x03
    1098:	fc 81       	ldd	r31, Y+4	; 0x04
    109a:	84 81       	ldd	r24, Z+4	; 0x04
    109c:	95 81       	ldd	r25, Z+5	; 0x05
    109e:	e9 81       	ldd	r30, Y+1	; 0x01
    10a0:	fa 81       	ldd	r31, Y+2	; 0x02
    10a2:	92 83       	std	Z+2, r25	; 0x02
    10a4:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    10a6:	eb 81       	ldd	r30, Y+3	; 0x03
    10a8:	fc 81       	ldd	r31, Y+4	; 0x04
    10aa:	11 86       	std	Z+9, r1	; 0x09
    10ac:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	80 81       	ld	r24, Z
    10b4:	81 50       	subi	r24, 0x01	; 1
    10b6:	e9 81       	ldd	r30, Y+1	; 0x01
    10b8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ba:	80 83       	st	Z, r24
}
    10bc:	0f 90       	pop	r0
    10be:	0f 90       	pop	r0
    10c0:	0f 90       	pop	r0
    10c2:	0f 90       	pop	r0
    10c4:	cf 91       	pop	r28
    10c6:	df 91       	pop	r29
    10c8:	08 95       	ret

000010ca <Blink_200ms>:

#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "task.h"
void Blink_200ms(void *pvParameters)
{
    10ca:	df 93       	push	r29
    10cc:	cf 93       	push	r28
    10ce:	00 d0       	rcall	.+0      	; 0x10d0 <Blink_200ms+0x6>
    10d0:	cd b7       	in	r28, 0x3d	; 61
    10d2:	de b7       	in	r29, 0x3e	; 62
    10d4:	9a 83       	std	Y+2, r25	; 0x02
    10d6:	89 83       	std	Y+1, r24	; 0x01
	DIO_VidSetPinDir(DIO_PIN0,DIO_PORTD,DIO_OUTPUT);
    10d8:	80 e0       	ldi	r24, 0x00	; 0
    10da:	63 e0       	ldi	r22, 0x03	; 3
    10dc:	41 e0       	ldi	r20, 0x01	; 1
    10de:	0e 94 c6 00 	call	0x18c	; 0x18c <DIO_VidSetPinDir>
	while(1)
	{
	TogelpinVal(DIO_PORTD,DIO_PIN0);
    10e2:	83 e0       	ldi	r24, 0x03	; 3
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	0e 94 49 00 	call	0x92	; 0x92 <TogelpinVal>
	vTaskDelay(200);
    10ea:	88 ec       	ldi	r24, 0xC8	; 200
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelay>
    10f2:	f7 cf       	rjmp	.-18     	; 0x10e2 <Blink_200ms+0x18>

000010f4 <Blink_1000ms>:
	}
}

void Blink_1000ms(void *pvParameters)
{
    10f4:	df 93       	push	r29
    10f6:	cf 93       	push	r28
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <Blink_1000ms+0x6>
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
    10fe:	9a 83       	std	Y+2, r25	; 0x02
    1100:	89 83       	std	Y+1, r24	; 0x01
DIO_VidSetPinDir(DIO_PIN1,DIO_PORTD,DIO_OUTPUT);
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	63 e0       	ldi	r22, 0x03	; 3
    1106:	41 e0       	ldi	r20, 0x01	; 1
    1108:	0e 94 c6 00 	call	0x18c	; 0x18c <DIO_VidSetPinDir>
while(1)
{
TogelpinVal(DIO_PORTD,DIO_PIN1);
    110c:	83 e0       	ldi	r24, 0x03	; 3
    110e:	61 e0       	ldi	r22, 0x01	; 1
    1110:	0e 94 49 00 	call	0x92	; 0x92 <TogelpinVal>
vTaskDelay(1000);
    1114:	88 ee       	ldi	r24, 0xE8	; 232
    1116:	93 e0       	ldi	r25, 0x03	; 3
    1118:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <vTaskDelay>
    111c:	f7 cf       	rjmp	.-18     	; 0x110c <Blink_1000ms+0x18>

0000111e <main>:
}
}

int main ()
{
    111e:	af 92       	push	r10
    1120:	bf 92       	push	r11
    1122:	cf 92       	push	r12
    1124:	df 92       	push	r13
    1126:	ef 92       	push	r14
    1128:	ff 92       	push	r15
    112a:	0f 93       	push	r16
    112c:	df 93       	push	r29
    112e:	cf 93       	push	r28
    1130:	cd b7       	in	r28, 0x3d	; 61
    1132:	de b7       	in	r29, 0x3e	; 62
xTaskCreate(Blink_200ms,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    1134:	85 e6       	ldi	r24, 0x65	; 101
    1136:	98 e0       	ldi	r25, 0x08	; 8
    1138:	60 e0       	ldi	r22, 0x00	; 0
    113a:	70 e0       	ldi	r23, 0x00	; 0
    113c:	45 e5       	ldi	r20, 0x55	; 85
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	20 e0       	ldi	r18, 0x00	; 0
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	01 e0       	ldi	r16, 0x01	; 1
    1146:	ee 24       	eor	r14, r14
    1148:	ff 24       	eor	r15, r15
    114a:	cc 24       	eor	r12, r12
    114c:	dd 24       	eor	r13, r13
    114e:	aa 24       	eor	r10, r10
    1150:	bb 24       	eor	r11, r11
    1152:	0e 94 1d 10 	call	0x203a	; 0x203a <xTaskGenericCreate>
xTaskCreate(Blink_1000ms,NULL,configMINIMAL_STACK_SIZE,NULL,2,NULL);
    1156:	8a e7       	ldi	r24, 0x7A	; 122
    1158:	98 e0       	ldi	r25, 0x08	; 8
    115a:	60 e0       	ldi	r22, 0x00	; 0
    115c:	70 e0       	ldi	r23, 0x00	; 0
    115e:	45 e5       	ldi	r20, 0x55	; 85
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	20 e0       	ldi	r18, 0x00	; 0
    1164:	30 e0       	ldi	r19, 0x00	; 0
    1166:	02 e0       	ldi	r16, 0x02	; 2
    1168:	ee 24       	eor	r14, r14
    116a:	ff 24       	eor	r15, r15
    116c:	cc 24       	eor	r12, r12
    116e:	dd 24       	eor	r13, r13
    1170:	aa 24       	eor	r10, r10
    1172:	bb 24       	eor	r11, r11
    1174:	0e 94 1d 10 	call	0x203a	; 0x203a <xTaskGenericCreate>

vTaskStartScheduler();
    1178:	0e 94 16 12 	call	0x242c	; 0x242c <vTaskStartScheduler>
    117c:	80 e0       	ldi	r24, 0x00	; 0
    117e:	90 e0       	ldi	r25, 0x00	; 0
}
    1180:	cf 91       	pop	r28
    1182:	df 91       	pop	r29
    1184:	0f 91       	pop	r16
    1186:	ff 90       	pop	r15
    1188:	ef 90       	pop	r14
    118a:	df 90       	pop	r13
    118c:	cf 90       	pop	r12
    118e:	bf 90       	pop	r11
    1190:	af 90       	pop	r10
    1192:	08 95       	ret

00001194 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1194:	df 93       	push	r29
    1196:	cf 93       	push	r28
    1198:	cd b7       	in	r28, 0x3d	; 61
    119a:	de b7       	in	r29, 0x3e	; 62
    119c:	28 97       	sbiw	r28, 0x08	; 8
    119e:	0f b6       	in	r0, 0x3f	; 63
    11a0:	f8 94       	cli
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	0f be       	out	0x3f, r0	; 63
    11a6:	cd bf       	out	0x3d, r28	; 61
    11a8:	9c 83       	std	Y+4, r25	; 0x04
    11aa:	8b 83       	std	Y+3, r24	; 0x03
    11ac:	7e 83       	std	Y+6, r23	; 0x06
    11ae:	6d 83       	std	Y+5, r22	; 0x05
    11b0:	58 87       	std	Y+8, r21	; 0x08
    11b2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11b4:	eb 81       	ldd	r30, Y+3	; 0x03
    11b6:	fc 81       	ldd	r31, Y+4	; 0x04
    11b8:	81 e1       	ldi	r24, 0x11	; 17
    11ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    11bc:	8b 81       	ldd	r24, Y+3	; 0x03
    11be:	9c 81       	ldd	r25, Y+4	; 0x04
    11c0:	01 97       	sbiw	r24, 0x01	; 1
    11c2:	9c 83       	std	Y+4, r25	; 0x04
    11c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    11c6:	eb 81       	ldd	r30, Y+3	; 0x03
    11c8:	fc 81       	ldd	r31, Y+4	; 0x04
    11ca:	82 e2       	ldi	r24, 0x22	; 34
    11cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ce:	8b 81       	ldd	r24, Y+3	; 0x03
    11d0:	9c 81       	ldd	r25, Y+4	; 0x04
    11d2:	01 97       	sbiw	r24, 0x01	; 1
    11d4:	9c 83       	std	Y+4, r25	; 0x04
    11d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    11d8:	eb 81       	ldd	r30, Y+3	; 0x03
    11da:	fc 81       	ldd	r31, Y+4	; 0x04
    11dc:	83 e3       	ldi	r24, 0x33	; 51
    11de:	80 83       	st	Z, r24
	pxTopOfStack--;
    11e0:	8b 81       	ldd	r24, Y+3	; 0x03
    11e2:	9c 81       	ldd	r25, Y+4	; 0x04
    11e4:	01 97       	sbiw	r24, 0x01	; 1
    11e6:	9c 83       	std	Y+4, r25	; 0x04
    11e8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    11ea:	8d 81       	ldd	r24, Y+5	; 0x05
    11ec:	9e 81       	ldd	r25, Y+6	; 0x06
    11ee:	9a 83       	std	Y+2, r25	; 0x02
    11f0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11f2:	89 81       	ldd	r24, Y+1	; 0x01
    11f4:	eb 81       	ldd	r30, Y+3	; 0x03
    11f6:	fc 81       	ldd	r31, Y+4	; 0x04
    11f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    11fa:	8b 81       	ldd	r24, Y+3	; 0x03
    11fc:	9c 81       	ldd	r25, Y+4	; 0x04
    11fe:	01 97       	sbiw	r24, 0x01	; 1
    1200:	9c 83       	std	Y+4, r25	; 0x04
    1202:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1204:	89 81       	ldd	r24, Y+1	; 0x01
    1206:	9a 81       	ldd	r25, Y+2	; 0x02
    1208:	89 2f       	mov	r24, r25
    120a:	99 27       	eor	r25, r25
    120c:	9a 83       	std	Y+2, r25	; 0x02
    120e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1210:	89 81       	ldd	r24, Y+1	; 0x01
    1212:	eb 81       	ldd	r30, Y+3	; 0x03
    1214:	fc 81       	ldd	r31, Y+4	; 0x04
    1216:	80 83       	st	Z, r24
	pxTopOfStack--;
    1218:	8b 81       	ldd	r24, Y+3	; 0x03
    121a:	9c 81       	ldd	r25, Y+4	; 0x04
    121c:	01 97       	sbiw	r24, 0x01	; 1
    121e:	9c 83       	std	Y+4, r25	; 0x04
    1220:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1222:	eb 81       	ldd	r30, Y+3	; 0x03
    1224:	fc 81       	ldd	r31, Y+4	; 0x04
    1226:	10 82       	st	Z, r1
	pxTopOfStack--;
    1228:	8b 81       	ldd	r24, Y+3	; 0x03
    122a:	9c 81       	ldd	r25, Y+4	; 0x04
    122c:	01 97       	sbiw	r24, 0x01	; 1
    122e:	9c 83       	std	Y+4, r25	; 0x04
    1230:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1232:	eb 81       	ldd	r30, Y+3	; 0x03
    1234:	fc 81       	ldd	r31, Y+4	; 0x04
    1236:	80 e8       	ldi	r24, 0x80	; 128
    1238:	80 83       	st	Z, r24
	pxTopOfStack--;
    123a:	8b 81       	ldd	r24, Y+3	; 0x03
    123c:	9c 81       	ldd	r25, Y+4	; 0x04
    123e:	01 97       	sbiw	r24, 0x01	; 1
    1240:	9c 83       	std	Y+4, r25	; 0x04
    1242:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1244:	eb 81       	ldd	r30, Y+3	; 0x03
    1246:	fc 81       	ldd	r31, Y+4	; 0x04
    1248:	10 82       	st	Z, r1
	pxTopOfStack--;
    124a:	8b 81       	ldd	r24, Y+3	; 0x03
    124c:	9c 81       	ldd	r25, Y+4	; 0x04
    124e:	01 97       	sbiw	r24, 0x01	; 1
    1250:	9c 83       	std	Y+4, r25	; 0x04
    1252:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1254:	eb 81       	ldd	r30, Y+3	; 0x03
    1256:	fc 81       	ldd	r31, Y+4	; 0x04
    1258:	82 e0       	ldi	r24, 0x02	; 2
    125a:	80 83       	st	Z, r24
	pxTopOfStack--;
    125c:	8b 81       	ldd	r24, Y+3	; 0x03
    125e:	9c 81       	ldd	r25, Y+4	; 0x04
    1260:	01 97       	sbiw	r24, 0x01	; 1
    1262:	9c 83       	std	Y+4, r25	; 0x04
    1264:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1266:	eb 81       	ldd	r30, Y+3	; 0x03
    1268:	fc 81       	ldd	r31, Y+4	; 0x04
    126a:	83 e0       	ldi	r24, 0x03	; 3
    126c:	80 83       	st	Z, r24
	pxTopOfStack--;
    126e:	8b 81       	ldd	r24, Y+3	; 0x03
    1270:	9c 81       	ldd	r25, Y+4	; 0x04
    1272:	01 97       	sbiw	r24, 0x01	; 1
    1274:	9c 83       	std	Y+4, r25	; 0x04
    1276:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1278:	eb 81       	ldd	r30, Y+3	; 0x03
    127a:	fc 81       	ldd	r31, Y+4	; 0x04
    127c:	84 e0       	ldi	r24, 0x04	; 4
    127e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1280:	8b 81       	ldd	r24, Y+3	; 0x03
    1282:	9c 81       	ldd	r25, Y+4	; 0x04
    1284:	01 97       	sbiw	r24, 0x01	; 1
    1286:	9c 83       	std	Y+4, r25	; 0x04
    1288:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    128a:	eb 81       	ldd	r30, Y+3	; 0x03
    128c:	fc 81       	ldd	r31, Y+4	; 0x04
    128e:	85 e0       	ldi	r24, 0x05	; 5
    1290:	80 83       	st	Z, r24
	pxTopOfStack--;
    1292:	8b 81       	ldd	r24, Y+3	; 0x03
    1294:	9c 81       	ldd	r25, Y+4	; 0x04
    1296:	01 97       	sbiw	r24, 0x01	; 1
    1298:	9c 83       	std	Y+4, r25	; 0x04
    129a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    129c:	eb 81       	ldd	r30, Y+3	; 0x03
    129e:	fc 81       	ldd	r31, Y+4	; 0x04
    12a0:	86 e0       	ldi	r24, 0x06	; 6
    12a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    12a4:	8b 81       	ldd	r24, Y+3	; 0x03
    12a6:	9c 81       	ldd	r25, Y+4	; 0x04
    12a8:	01 97       	sbiw	r24, 0x01	; 1
    12aa:	9c 83       	std	Y+4, r25	; 0x04
    12ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    12ae:	eb 81       	ldd	r30, Y+3	; 0x03
    12b0:	fc 81       	ldd	r31, Y+4	; 0x04
    12b2:	87 e0       	ldi	r24, 0x07	; 7
    12b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    12b6:	8b 81       	ldd	r24, Y+3	; 0x03
    12b8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ba:	01 97       	sbiw	r24, 0x01	; 1
    12bc:	9c 83       	std	Y+4, r25	; 0x04
    12be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    12c0:	eb 81       	ldd	r30, Y+3	; 0x03
    12c2:	fc 81       	ldd	r31, Y+4	; 0x04
    12c4:	88 e0       	ldi	r24, 0x08	; 8
    12c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    12c8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ca:	9c 81       	ldd	r25, Y+4	; 0x04
    12cc:	01 97       	sbiw	r24, 0x01	; 1
    12ce:	9c 83       	std	Y+4, r25	; 0x04
    12d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    12d2:	eb 81       	ldd	r30, Y+3	; 0x03
    12d4:	fc 81       	ldd	r31, Y+4	; 0x04
    12d6:	89 e0       	ldi	r24, 0x09	; 9
    12d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    12da:	8b 81       	ldd	r24, Y+3	; 0x03
    12dc:	9c 81       	ldd	r25, Y+4	; 0x04
    12de:	01 97       	sbiw	r24, 0x01	; 1
    12e0:	9c 83       	std	Y+4, r25	; 0x04
    12e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    12e4:	eb 81       	ldd	r30, Y+3	; 0x03
    12e6:	fc 81       	ldd	r31, Y+4	; 0x04
    12e8:	80 e1       	ldi	r24, 0x10	; 16
    12ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    12ec:	8b 81       	ldd	r24, Y+3	; 0x03
    12ee:	9c 81       	ldd	r25, Y+4	; 0x04
    12f0:	01 97       	sbiw	r24, 0x01	; 1
    12f2:	9c 83       	std	Y+4, r25	; 0x04
    12f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    12f6:	eb 81       	ldd	r30, Y+3	; 0x03
    12f8:	fc 81       	ldd	r31, Y+4	; 0x04
    12fa:	81 e1       	ldi	r24, 0x11	; 17
    12fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    12fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1300:	9c 81       	ldd	r25, Y+4	; 0x04
    1302:	01 97       	sbiw	r24, 0x01	; 1
    1304:	9c 83       	std	Y+4, r25	; 0x04
    1306:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1308:	eb 81       	ldd	r30, Y+3	; 0x03
    130a:	fc 81       	ldd	r31, Y+4	; 0x04
    130c:	82 e1       	ldi	r24, 0x12	; 18
    130e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	9c 81       	ldd	r25, Y+4	; 0x04
    1314:	01 97       	sbiw	r24, 0x01	; 1
    1316:	9c 83       	std	Y+4, r25	; 0x04
    1318:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    131a:	eb 81       	ldd	r30, Y+3	; 0x03
    131c:	fc 81       	ldd	r31, Y+4	; 0x04
    131e:	83 e1       	ldi	r24, 0x13	; 19
    1320:	80 83       	st	Z, r24
	pxTopOfStack--;
    1322:	8b 81       	ldd	r24, Y+3	; 0x03
    1324:	9c 81       	ldd	r25, Y+4	; 0x04
    1326:	01 97       	sbiw	r24, 0x01	; 1
    1328:	9c 83       	std	Y+4, r25	; 0x04
    132a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    132c:	eb 81       	ldd	r30, Y+3	; 0x03
    132e:	fc 81       	ldd	r31, Y+4	; 0x04
    1330:	84 e1       	ldi	r24, 0x14	; 20
    1332:	80 83       	st	Z, r24
	pxTopOfStack--;
    1334:	8b 81       	ldd	r24, Y+3	; 0x03
    1336:	9c 81       	ldd	r25, Y+4	; 0x04
    1338:	01 97       	sbiw	r24, 0x01	; 1
    133a:	9c 83       	std	Y+4, r25	; 0x04
    133c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    133e:	eb 81       	ldd	r30, Y+3	; 0x03
    1340:	fc 81       	ldd	r31, Y+4	; 0x04
    1342:	85 e1       	ldi	r24, 0x15	; 21
    1344:	80 83       	st	Z, r24
	pxTopOfStack--;
    1346:	8b 81       	ldd	r24, Y+3	; 0x03
    1348:	9c 81       	ldd	r25, Y+4	; 0x04
    134a:	01 97       	sbiw	r24, 0x01	; 1
    134c:	9c 83       	std	Y+4, r25	; 0x04
    134e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1350:	eb 81       	ldd	r30, Y+3	; 0x03
    1352:	fc 81       	ldd	r31, Y+4	; 0x04
    1354:	86 e1       	ldi	r24, 0x16	; 22
    1356:	80 83       	st	Z, r24
	pxTopOfStack--;
    1358:	8b 81       	ldd	r24, Y+3	; 0x03
    135a:	9c 81       	ldd	r25, Y+4	; 0x04
    135c:	01 97       	sbiw	r24, 0x01	; 1
    135e:	9c 83       	std	Y+4, r25	; 0x04
    1360:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1362:	eb 81       	ldd	r30, Y+3	; 0x03
    1364:	fc 81       	ldd	r31, Y+4	; 0x04
    1366:	87 e1       	ldi	r24, 0x17	; 23
    1368:	80 83       	st	Z, r24
	pxTopOfStack--;
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	9c 81       	ldd	r25, Y+4	; 0x04
    136e:	01 97       	sbiw	r24, 0x01	; 1
    1370:	9c 83       	std	Y+4, r25	; 0x04
    1372:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	88 e1       	ldi	r24, 0x18	; 24
    137a:	80 83       	st	Z, r24
	pxTopOfStack--;
    137c:	8b 81       	ldd	r24, Y+3	; 0x03
    137e:	9c 81       	ldd	r25, Y+4	; 0x04
    1380:	01 97       	sbiw	r24, 0x01	; 1
    1382:	9c 83       	std	Y+4, r25	; 0x04
    1384:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1386:	eb 81       	ldd	r30, Y+3	; 0x03
    1388:	fc 81       	ldd	r31, Y+4	; 0x04
    138a:	89 e1       	ldi	r24, 0x19	; 25
    138c:	80 83       	st	Z, r24
	pxTopOfStack--;
    138e:	8b 81       	ldd	r24, Y+3	; 0x03
    1390:	9c 81       	ldd	r25, Y+4	; 0x04
    1392:	01 97       	sbiw	r24, 0x01	; 1
    1394:	9c 83       	std	Y+4, r25	; 0x04
    1396:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1398:	eb 81       	ldd	r30, Y+3	; 0x03
    139a:	fc 81       	ldd	r31, Y+4	; 0x04
    139c:	80 e2       	ldi	r24, 0x20	; 32
    139e:	80 83       	st	Z, r24
	pxTopOfStack--;
    13a0:	8b 81       	ldd	r24, Y+3	; 0x03
    13a2:	9c 81       	ldd	r25, Y+4	; 0x04
    13a4:	01 97       	sbiw	r24, 0x01	; 1
    13a6:	9c 83       	std	Y+4, r25	; 0x04
    13a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    13aa:	eb 81       	ldd	r30, Y+3	; 0x03
    13ac:	fc 81       	ldd	r31, Y+4	; 0x04
    13ae:	81 e2       	ldi	r24, 0x21	; 33
    13b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13b2:	8b 81       	ldd	r24, Y+3	; 0x03
    13b4:	9c 81       	ldd	r25, Y+4	; 0x04
    13b6:	01 97       	sbiw	r24, 0x01	; 1
    13b8:	9c 83       	std	Y+4, r25	; 0x04
    13ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    13bc:	eb 81       	ldd	r30, Y+3	; 0x03
    13be:	fc 81       	ldd	r31, Y+4	; 0x04
    13c0:	82 e2       	ldi	r24, 0x22	; 34
    13c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c4:	8b 81       	ldd	r24, Y+3	; 0x03
    13c6:	9c 81       	ldd	r25, Y+4	; 0x04
    13c8:	01 97       	sbiw	r24, 0x01	; 1
    13ca:	9c 83       	std	Y+4, r25	; 0x04
    13cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    13ce:	eb 81       	ldd	r30, Y+3	; 0x03
    13d0:	fc 81       	ldd	r31, Y+4	; 0x04
    13d2:	83 e2       	ldi	r24, 0x23	; 35
    13d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d6:	8b 81       	ldd	r24, Y+3	; 0x03
    13d8:	9c 81       	ldd	r25, Y+4	; 0x04
    13da:	01 97       	sbiw	r24, 0x01	; 1
    13dc:	9c 83       	std	Y+4, r25	; 0x04
    13de:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    13e0:	8f 81       	ldd	r24, Y+7	; 0x07
    13e2:	98 85       	ldd	r25, Y+8	; 0x08
    13e4:	9a 83       	std	Y+2, r25	; 0x02
    13e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    13e8:	89 81       	ldd	r24, Y+1	; 0x01
    13ea:	eb 81       	ldd	r30, Y+3	; 0x03
    13ec:	fc 81       	ldd	r31, Y+4	; 0x04
    13ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f0:	8b 81       	ldd	r24, Y+3	; 0x03
    13f2:	9c 81       	ldd	r25, Y+4	; 0x04
    13f4:	01 97       	sbiw	r24, 0x01	; 1
    13f6:	9c 83       	std	Y+4, r25	; 0x04
    13f8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    13fa:	89 81       	ldd	r24, Y+1	; 0x01
    13fc:	9a 81       	ldd	r25, Y+2	; 0x02
    13fe:	89 2f       	mov	r24, r25
    1400:	99 27       	eor	r25, r25
    1402:	9a 83       	std	Y+2, r25	; 0x02
    1404:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1406:	89 81       	ldd	r24, Y+1	; 0x01
    1408:	eb 81       	ldd	r30, Y+3	; 0x03
    140a:	fc 81       	ldd	r31, Y+4	; 0x04
    140c:	80 83       	st	Z, r24
	pxTopOfStack--;
    140e:	8b 81       	ldd	r24, Y+3	; 0x03
    1410:	9c 81       	ldd	r25, Y+4	; 0x04
    1412:	01 97       	sbiw	r24, 0x01	; 1
    1414:	9c 83       	std	Y+4, r25	; 0x04
    1416:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1418:	eb 81       	ldd	r30, Y+3	; 0x03
    141a:	fc 81       	ldd	r31, Y+4	; 0x04
    141c:	86 e2       	ldi	r24, 0x26	; 38
    141e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1420:	8b 81       	ldd	r24, Y+3	; 0x03
    1422:	9c 81       	ldd	r25, Y+4	; 0x04
    1424:	01 97       	sbiw	r24, 0x01	; 1
    1426:	9c 83       	std	Y+4, r25	; 0x04
    1428:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    142a:	eb 81       	ldd	r30, Y+3	; 0x03
    142c:	fc 81       	ldd	r31, Y+4	; 0x04
    142e:	87 e2       	ldi	r24, 0x27	; 39
    1430:	80 83       	st	Z, r24
	pxTopOfStack--;
    1432:	8b 81       	ldd	r24, Y+3	; 0x03
    1434:	9c 81       	ldd	r25, Y+4	; 0x04
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	9c 83       	std	Y+4, r25	; 0x04
    143a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    143c:	eb 81       	ldd	r30, Y+3	; 0x03
    143e:	fc 81       	ldd	r31, Y+4	; 0x04
    1440:	88 e2       	ldi	r24, 0x28	; 40
    1442:	80 83       	st	Z, r24
	pxTopOfStack--;
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	01 97       	sbiw	r24, 0x01	; 1
    144a:	9c 83       	std	Y+4, r25	; 0x04
    144c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    144e:	eb 81       	ldd	r30, Y+3	; 0x03
    1450:	fc 81       	ldd	r31, Y+4	; 0x04
    1452:	89 e2       	ldi	r24, 0x29	; 41
    1454:	80 83       	st	Z, r24
	pxTopOfStack--;
    1456:	8b 81       	ldd	r24, Y+3	; 0x03
    1458:	9c 81       	ldd	r25, Y+4	; 0x04
    145a:	01 97       	sbiw	r24, 0x01	; 1
    145c:	9c 83       	std	Y+4, r25	; 0x04
    145e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1460:	eb 81       	ldd	r30, Y+3	; 0x03
    1462:	fc 81       	ldd	r31, Y+4	; 0x04
    1464:	80 e3       	ldi	r24, 0x30	; 48
    1466:	80 83       	st	Z, r24
	pxTopOfStack--;
    1468:	8b 81       	ldd	r24, Y+3	; 0x03
    146a:	9c 81       	ldd	r25, Y+4	; 0x04
    146c:	01 97       	sbiw	r24, 0x01	; 1
    146e:	9c 83       	std	Y+4, r25	; 0x04
    1470:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1472:	eb 81       	ldd	r30, Y+3	; 0x03
    1474:	fc 81       	ldd	r31, Y+4	; 0x04
    1476:	81 e3       	ldi	r24, 0x31	; 49
    1478:	80 83       	st	Z, r24
	pxTopOfStack--;
    147a:	8b 81       	ldd	r24, Y+3	; 0x03
    147c:	9c 81       	ldd	r25, Y+4	; 0x04
    147e:	01 97       	sbiw	r24, 0x01	; 1
    1480:	9c 83       	std	Y+4, r25	; 0x04
    1482:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1484:	8b 81       	ldd	r24, Y+3	; 0x03
    1486:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1488:	28 96       	adiw	r28, 0x08	; 8
    148a:	0f b6       	in	r0, 0x3f	; 63
    148c:	f8 94       	cli
    148e:	de bf       	out	0x3e, r29	; 62
    1490:	0f be       	out	0x3f, r0	; 63
    1492:	cd bf       	out	0x3d, r28	; 61
    1494:	cf 91       	pop	r28
    1496:	df 91       	pop	r29
    1498:	08 95       	ret

0000149a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    149a:	df 93       	push	r29
    149c:	cf 93       	push	r28
    149e:	cd b7       	in	r28, 0x3d	; 61
    14a0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    14a2:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    14a6:	a0 91 fc 02 	lds	r26, 0x02FC
    14aa:	b0 91 fd 02 	lds	r27, 0x02FD
    14ae:	cd 91       	ld	r28, X+
    14b0:	cd bf       	out	0x3d, r28	; 61
    14b2:	dd 91       	ld	r29, X+
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	ff 91       	pop	r31
    14b8:	ef 91       	pop	r30
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	bf 91       	pop	r27
    14c0:	af 91       	pop	r26
    14c2:	9f 91       	pop	r25
    14c4:	8f 91       	pop	r24
    14c6:	7f 91       	pop	r23
    14c8:	6f 91       	pop	r22
    14ca:	5f 91       	pop	r21
    14cc:	4f 91       	pop	r20
    14ce:	3f 91       	pop	r19
    14d0:	2f 91       	pop	r18
    14d2:	1f 91       	pop	r17
    14d4:	0f 91       	pop	r16
    14d6:	ff 90       	pop	r15
    14d8:	ef 90       	pop	r14
    14da:	df 90       	pop	r13
    14dc:	cf 90       	pop	r12
    14de:	bf 90       	pop	r11
    14e0:	af 90       	pop	r10
    14e2:	9f 90       	pop	r9
    14e4:	8f 90       	pop	r8
    14e6:	7f 90       	pop	r7
    14e8:	6f 90       	pop	r6
    14ea:	5f 90       	pop	r5
    14ec:	4f 90       	pop	r4
    14ee:	3f 90       	pop	r3
    14f0:	2f 90       	pop	r2
    14f2:	1f 90       	pop	r1
    14f4:	0f 90       	pop	r0
    14f6:	0f be       	out	0x3f, r0	; 63
    14f8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    14fa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    14fc:	81 e0       	ldi	r24, 0x01	; 1
}
    14fe:	cf 91       	pop	r28
    1500:	df 91       	pop	r29
    1502:	08 95       	ret

00001504 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1504:	df 93       	push	r29
    1506:	cf 93       	push	r28
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    150c:	cf 91       	pop	r28
    150e:	df 91       	pop	r29
    1510:	08 95       	ret

00001512 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1512:	0f 92       	push	r0
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	0f 92       	push	r0
    151a:	1f 92       	push	r1
    151c:	11 24       	eor	r1, r1
    151e:	2f 92       	push	r2
    1520:	3f 92       	push	r3
    1522:	4f 92       	push	r4
    1524:	5f 92       	push	r5
    1526:	6f 92       	push	r6
    1528:	7f 92       	push	r7
    152a:	8f 92       	push	r8
    152c:	9f 92       	push	r9
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	2f 93       	push	r18
    1540:	3f 93       	push	r19
    1542:	4f 93       	push	r20
    1544:	5f 93       	push	r21
    1546:	6f 93       	push	r22
    1548:	7f 93       	push	r23
    154a:	8f 93       	push	r24
    154c:	9f 93       	push	r25
    154e:	af 93       	push	r26
    1550:	bf 93       	push	r27
    1552:	cf 93       	push	r28
    1554:	df 93       	push	r29
    1556:	ef 93       	push	r30
    1558:	ff 93       	push	r31
    155a:	a0 91 fc 02 	lds	r26, 0x02FC
    155e:	b0 91 fd 02 	lds	r27, 0x02FD
    1562:	0d b6       	in	r0, 0x3d	; 61
    1564:	0d 92       	st	X+, r0
    1566:	0e b6       	in	r0, 0x3e	; 62
    1568:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    156a:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    156e:	a0 91 fc 02 	lds	r26, 0x02FC
    1572:	b0 91 fd 02 	lds	r27, 0x02FD
    1576:	cd 91       	ld	r28, X+
    1578:	cd bf       	out	0x3d, r28	; 61
    157a:	dd 91       	ld	r29, X+
    157c:	de bf       	out	0x3e, r29	; 62
    157e:	ff 91       	pop	r31
    1580:	ef 91       	pop	r30
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	bf 91       	pop	r27
    1588:	af 91       	pop	r26
    158a:	9f 91       	pop	r25
    158c:	8f 91       	pop	r24
    158e:	7f 91       	pop	r23
    1590:	6f 91       	pop	r22
    1592:	5f 91       	pop	r21
    1594:	4f 91       	pop	r20
    1596:	3f 91       	pop	r19
    1598:	2f 91       	pop	r18
    159a:	1f 91       	pop	r17
    159c:	0f 91       	pop	r16
    159e:	ff 90       	pop	r15
    15a0:	ef 90       	pop	r14
    15a2:	df 90       	pop	r13
    15a4:	cf 90       	pop	r12
    15a6:	bf 90       	pop	r11
    15a8:	af 90       	pop	r10
    15aa:	9f 90       	pop	r9
    15ac:	8f 90       	pop	r8
    15ae:	7f 90       	pop	r7
    15b0:	6f 90       	pop	r6
    15b2:	5f 90       	pop	r5
    15b4:	4f 90       	pop	r4
    15b6:	3f 90       	pop	r3
    15b8:	2f 90       	pop	r2
    15ba:	1f 90       	pop	r1
    15bc:	0f 90       	pop	r0
    15be:	0f be       	out	0x3f, r0	; 63
    15c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15c2:	08 95       	ret

000015c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15c4:	0f 92       	push	r0
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
    15cc:	1f 92       	push	r1
    15ce:	11 24       	eor	r1, r1
    15d0:	2f 92       	push	r2
    15d2:	3f 92       	push	r3
    15d4:	4f 92       	push	r4
    15d6:	5f 92       	push	r5
    15d8:	6f 92       	push	r6
    15da:	7f 92       	push	r7
    15dc:	8f 92       	push	r8
    15de:	9f 92       	push	r9
    15e0:	af 92       	push	r10
    15e2:	bf 92       	push	r11
    15e4:	cf 92       	push	r12
    15e6:	df 92       	push	r13
    15e8:	ef 92       	push	r14
    15ea:	ff 92       	push	r15
    15ec:	0f 93       	push	r16
    15ee:	1f 93       	push	r17
    15f0:	2f 93       	push	r18
    15f2:	3f 93       	push	r19
    15f4:	4f 93       	push	r20
    15f6:	5f 93       	push	r21
    15f8:	6f 93       	push	r22
    15fa:	7f 93       	push	r23
    15fc:	8f 93       	push	r24
    15fe:	9f 93       	push	r25
    1600:	af 93       	push	r26
    1602:	bf 93       	push	r27
    1604:	cf 93       	push	r28
    1606:	df 93       	push	r29
    1608:	ef 93       	push	r30
    160a:	ff 93       	push	r31
    160c:	a0 91 fc 02 	lds	r26, 0x02FC
    1610:	b0 91 fd 02 	lds	r27, 0x02FD
    1614:	0d b6       	in	r0, 0x3d	; 61
    1616:	0d 92       	st	X+, r0
    1618:	0e b6       	in	r0, 0x3e	; 62
    161a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    161c:	0e 94 24 13 	call	0x2648	; 0x2648 <vTaskIncrementTick>
	vTaskSwitchContext();
    1620:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1624:	a0 91 fc 02 	lds	r26, 0x02FC
    1628:	b0 91 fd 02 	lds	r27, 0x02FD
    162c:	cd 91       	ld	r28, X+
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	dd 91       	ld	r29, X+
    1632:	de bf       	out	0x3e, r29	; 62
    1634:	ff 91       	pop	r31
    1636:	ef 91       	pop	r30
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	bf 91       	pop	r27
    163e:	af 91       	pop	r26
    1640:	9f 91       	pop	r25
    1642:	8f 91       	pop	r24
    1644:	7f 91       	pop	r23
    1646:	6f 91       	pop	r22
    1648:	5f 91       	pop	r21
    164a:	4f 91       	pop	r20
    164c:	3f 91       	pop	r19
    164e:	2f 91       	pop	r18
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	ff 90       	pop	r15
    1656:	ef 90       	pop	r14
    1658:	df 90       	pop	r13
    165a:	cf 90       	pop	r12
    165c:	bf 90       	pop	r11
    165e:	af 90       	pop	r10
    1660:	9f 90       	pop	r9
    1662:	8f 90       	pop	r8
    1664:	7f 90       	pop	r7
    1666:	6f 90       	pop	r6
    1668:	5f 90       	pop	r5
    166a:	4f 90       	pop	r4
    166c:	3f 90       	pop	r3
    166e:	2f 90       	pop	r2
    1670:	1f 90       	pop	r1
    1672:	0f 90       	pop	r0
    1674:	0f be       	out	0x3f, r0	; 63
    1676:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1678:	08 95       	ret

0000167a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    167a:	df 93       	push	r29
    167c:	cf 93       	push	r28
    167e:	00 d0       	rcall	.+0      	; 0x1680 <prvSetupTimerInterrupt+0x6>
    1680:	00 d0       	rcall	.+0      	; 0x1682 <prvSetupTimerInterrupt+0x8>
    1682:	00 d0       	rcall	.+0      	; 0x1684 <prvSetupTimerInterrupt+0xa>
    1684:	cd b7       	in	r28, 0x3d	; 61
    1686:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1688:	80 e4       	ldi	r24, 0x40	; 64
    168a:	9f e1       	ldi	r25, 0x1F	; 31
    168c:	a0 e0       	ldi	r26, 0x00	; 0
    168e:	b0 e0       	ldi	r27, 0x00	; 0
    1690:	8b 83       	std	Y+3, r24	; 0x03
    1692:	9c 83       	std	Y+4, r25	; 0x04
    1694:	ad 83       	std	Y+5, r26	; 0x05
    1696:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1698:	8b 81       	ldd	r24, Y+3	; 0x03
    169a:	9c 81       	ldd	r25, Y+4	; 0x04
    169c:	ad 81       	ldd	r26, Y+5	; 0x05
    169e:	be 81       	ldd	r27, Y+6	; 0x06
    16a0:	68 94       	set
    16a2:	15 f8       	bld	r1, 5
    16a4:	b6 95       	lsr	r27
    16a6:	a7 95       	ror	r26
    16a8:	97 95       	ror	r25
    16aa:	87 95       	ror	r24
    16ac:	16 94       	lsr	r1
    16ae:	d1 f7       	brne	.-12     	; 0x16a4 <prvSetupTimerInterrupt+0x2a>
    16b0:	8b 83       	std	Y+3, r24	; 0x03
    16b2:	9c 83       	std	Y+4, r25	; 0x04
    16b4:	ad 83       	std	Y+5, r26	; 0x05
    16b6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    16b8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ba:	9c 81       	ldd	r25, Y+4	; 0x04
    16bc:	ad 81       	ldd	r26, Y+5	; 0x05
    16be:	be 81       	ldd	r27, Y+6	; 0x06
    16c0:	01 97       	sbiw	r24, 0x01	; 1
    16c2:	a1 09       	sbc	r26, r1
    16c4:	b1 09       	sbc	r27, r1
    16c6:	8b 83       	std	Y+3, r24	; 0x03
    16c8:	9c 83       	std	Y+4, r25	; 0x04
    16ca:	ad 83       	std	Y+5, r26	; 0x05
    16cc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    16ce:	8b 81       	ldd	r24, Y+3	; 0x03
    16d0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    16d2:	8b 81       	ldd	r24, Y+3	; 0x03
    16d4:	9c 81       	ldd	r25, Y+4	; 0x04
    16d6:	ad 81       	ldd	r26, Y+5	; 0x05
    16d8:	be 81       	ldd	r27, Y+6	; 0x06
    16da:	89 2f       	mov	r24, r25
    16dc:	9a 2f       	mov	r25, r26
    16de:	ab 2f       	mov	r26, r27
    16e0:	bb 27       	eor	r27, r27
    16e2:	8b 83       	std	Y+3, r24	; 0x03
    16e4:	9c 83       	std	Y+4, r25	; 0x04
    16e6:	ad 83       	std	Y+5, r26	; 0x05
    16e8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    16ea:	8b 81       	ldd	r24, Y+3	; 0x03
    16ec:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    16ee:	eb e4       	ldi	r30, 0x4B	; 75
    16f0:	f0 e0       	ldi	r31, 0x00	; 0
    16f2:	8a 81       	ldd	r24, Y+2	; 0x02
    16f4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    16f6:	ea e4       	ldi	r30, 0x4A	; 74
    16f8:	f0 e0       	ldi	r31, 0x00	; 0
    16fa:	89 81       	ldd	r24, Y+1	; 0x01
    16fc:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    16fe:	8b e0       	ldi	r24, 0x0B	; 11
    1700:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1702:	ee e4       	ldi	r30, 0x4E	; 78
    1704:	f0 e0       	ldi	r31, 0x00	; 0
    1706:	89 81       	ldd	r24, Y+1	; 0x01
    1708:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    170a:	e9 e5       	ldi	r30, 0x59	; 89
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	80 81       	ld	r24, Z
    1710:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1712:	89 81       	ldd	r24, Y+1	; 0x01
    1714:	80 61       	ori	r24, 0x10	; 16
    1716:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1718:	e9 e5       	ldi	r30, 0x59	; 89
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	89 81       	ldd	r24, Y+1	; 0x01
    171e:	80 83       	st	Z, r24
}
    1720:	26 96       	adiw	r28, 0x06	; 6
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
    172c:	cf 91       	pop	r28
    172e:	df 91       	pop	r29
    1730:	08 95       	ret

00001732 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1732:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1736:	18 95       	reti

00001738 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1738:	df 93       	push	r29
    173a:	cf 93       	push	r28
    173c:	cd b7       	in	r28, 0x3d	; 61
    173e:	de b7       	in	r29, 0x3e	; 62
    1740:	28 97       	sbiw	r28, 0x08	; 8
    1742:	0f b6       	in	r0, 0x3f	; 63
    1744:	f8 94       	cli
    1746:	de bf       	out	0x3e, r29	; 62
    1748:	0f be       	out	0x3f, r0	; 63
    174a:	cd bf       	out	0x3d, r28	; 61
    174c:	8f 83       	std	Y+7, r24	; 0x07
    174e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1750:	1a 82       	std	Y+2, r1	; 0x02
    1752:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1754:	8f 81       	ldd	r24, Y+7	; 0x07
    1756:	88 23       	and	r24, r24
    1758:	09 f4       	brne	.+2      	; 0x175c <xQueueCreate+0x24>
    175a:	8c c0       	rjmp	.+280    	; 0x1874 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    175c:	8f e1       	ldi	r24, 0x1F	; 31
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	0e 94 be 06 	call	0xd7c	; 0xd7c <pvPortMalloc>
    1764:	9e 83       	std	Y+6, r25	; 0x06
    1766:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1768:	8d 81       	ldd	r24, Y+5	; 0x05
    176a:	9e 81       	ldd	r25, Y+6	; 0x06
    176c:	00 97       	sbiw	r24, 0x00	; 0
    176e:	09 f4       	brne	.+2      	; 0x1772 <xQueueCreate+0x3a>
    1770:	81 c0       	rjmp	.+258    	; 0x1874 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1772:	8f 81       	ldd	r24, Y+7	; 0x07
    1774:	28 2f       	mov	r18, r24
    1776:	30 e0       	ldi	r19, 0x00	; 0
    1778:	88 85       	ldd	r24, Y+8	; 0x08
    177a:	88 2f       	mov	r24, r24
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	ac 01       	movw	r20, r24
    1780:	24 9f       	mul	r18, r20
    1782:	c0 01       	movw	r24, r0
    1784:	25 9f       	mul	r18, r21
    1786:	90 0d       	add	r25, r0
    1788:	34 9f       	mul	r19, r20
    178a:	90 0d       	add	r25, r0
    178c:	11 24       	eor	r1, r1
    178e:	01 96       	adiw	r24, 0x01	; 1
    1790:	9c 83       	std	Y+4, r25	; 0x04
    1792:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1794:	8b 81       	ldd	r24, Y+3	; 0x03
    1796:	9c 81       	ldd	r25, Y+4	; 0x04
    1798:	0e 94 be 06 	call	0xd7c	; 0xd7c <pvPortMalloc>
    179c:	ed 81       	ldd	r30, Y+5	; 0x05
    179e:	fe 81       	ldd	r31, Y+6	; 0x06
    17a0:	91 83       	std	Z+1, r25	; 0x01
    17a2:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    17a4:	ed 81       	ldd	r30, Y+5	; 0x05
    17a6:	fe 81       	ldd	r31, Y+6	; 0x06
    17a8:	80 81       	ld	r24, Z
    17aa:	91 81       	ldd	r25, Z+1	; 0x01
    17ac:	00 97       	sbiw	r24, 0x00	; 0
    17ae:	09 f4       	brne	.+2      	; 0x17b2 <xQueueCreate+0x7a>
    17b0:	5d c0       	rjmp	.+186    	; 0x186c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    17b2:	ed 81       	ldd	r30, Y+5	; 0x05
    17b4:	fe 81       	ldd	r31, Y+6	; 0x06
    17b6:	40 81       	ld	r20, Z
    17b8:	51 81       	ldd	r21, Z+1	; 0x01
    17ba:	8f 81       	ldd	r24, Y+7	; 0x07
    17bc:	28 2f       	mov	r18, r24
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	88 85       	ldd	r24, Y+8	; 0x08
    17c2:	88 2f       	mov	r24, r24
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	bc 01       	movw	r22, r24
    17c8:	26 9f       	mul	r18, r22
    17ca:	c0 01       	movw	r24, r0
    17cc:	27 9f       	mul	r18, r23
    17ce:	90 0d       	add	r25, r0
    17d0:	36 9f       	mul	r19, r22
    17d2:	90 0d       	add	r25, r0
    17d4:	11 24       	eor	r1, r1
    17d6:	84 0f       	add	r24, r20
    17d8:	95 1f       	adc	r25, r21
    17da:	ed 81       	ldd	r30, Y+5	; 0x05
    17dc:	fe 81       	ldd	r31, Y+6	; 0x06
    17de:	93 83       	std	Z+3, r25	; 0x03
    17e0:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    17e2:	ed 81       	ldd	r30, Y+5	; 0x05
    17e4:	fe 81       	ldd	r31, Y+6	; 0x06
    17e6:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    17e8:	ed 81       	ldd	r30, Y+5	; 0x05
    17ea:	fe 81       	ldd	r31, Y+6	; 0x06
    17ec:	80 81       	ld	r24, Z
    17ee:	91 81       	ldd	r25, Z+1	; 0x01
    17f0:	ed 81       	ldd	r30, Y+5	; 0x05
    17f2:	fe 81       	ldd	r31, Y+6	; 0x06
    17f4:	95 83       	std	Z+5, r25	; 0x05
    17f6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    17f8:	ed 81       	ldd	r30, Y+5	; 0x05
    17fa:	fe 81       	ldd	r31, Y+6	; 0x06
    17fc:	40 81       	ld	r20, Z
    17fe:	51 81       	ldd	r21, Z+1	; 0x01
    1800:	8f 81       	ldd	r24, Y+7	; 0x07
    1802:	88 2f       	mov	r24, r24
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	9c 01       	movw	r18, r24
    1808:	21 50       	subi	r18, 0x01	; 1
    180a:	30 40       	sbci	r19, 0x00	; 0
    180c:	88 85       	ldd	r24, Y+8	; 0x08
    180e:	88 2f       	mov	r24, r24
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	bc 01       	movw	r22, r24
    1814:	26 9f       	mul	r18, r22
    1816:	c0 01       	movw	r24, r0
    1818:	27 9f       	mul	r18, r23
    181a:	90 0d       	add	r25, r0
    181c:	36 9f       	mul	r19, r22
    181e:	90 0d       	add	r25, r0
    1820:	11 24       	eor	r1, r1
    1822:	84 0f       	add	r24, r20
    1824:	95 1f       	adc	r25, r21
    1826:	ed 81       	ldd	r30, Y+5	; 0x05
    1828:	fe 81       	ldd	r31, Y+6	; 0x06
    182a:	97 83       	std	Z+7, r25	; 0x07
    182c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    182e:	ed 81       	ldd	r30, Y+5	; 0x05
    1830:	fe 81       	ldd	r31, Y+6	; 0x06
    1832:	8f 81       	ldd	r24, Y+7	; 0x07
    1834:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1836:	ed 81       	ldd	r30, Y+5	; 0x05
    1838:	fe 81       	ldd	r31, Y+6	; 0x06
    183a:	88 85       	ldd	r24, Y+8	; 0x08
    183c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    183e:	ed 81       	ldd	r30, Y+5	; 0x05
    1840:	fe 81       	ldd	r31, Y+6	; 0x06
    1842:	8f ef       	ldi	r24, 0xFF	; 255
    1844:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1846:	ed 81       	ldd	r30, Y+5	; 0x05
    1848:	fe 81       	ldd	r31, Y+6	; 0x06
    184a:	8f ef       	ldi	r24, 0xFF	; 255
    184c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    184e:	8d 81       	ldd	r24, Y+5	; 0x05
    1850:	9e 81       	ldd	r25, Y+6	; 0x06
    1852:	08 96       	adiw	r24, 0x08	; 8
    1854:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1858:	8d 81       	ldd	r24, Y+5	; 0x05
    185a:	9e 81       	ldd	r25, Y+6	; 0x06
    185c:	41 96       	adiw	r24, 0x11	; 17
    185e:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1862:	8d 81       	ldd	r24, Y+5	; 0x05
    1864:	9e 81       	ldd	r25, Y+6	; 0x06
    1866:	9a 83       	std	Y+2, r25	; 0x02
    1868:	89 83       	std	Y+1, r24	; 0x01
    186a:	04 c0       	rjmp	.+8      	; 0x1874 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    186c:	8d 81       	ldd	r24, Y+5	; 0x05
    186e:	9e 81       	ldd	r25, Y+6	; 0x06
    1870:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1874:	89 81       	ldd	r24, Y+1	; 0x01
    1876:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1878:	28 96       	adiw	r28, 0x08	; 8
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
    187e:	de bf       	out	0x3e, r29	; 62
    1880:	0f be       	out	0x3f, r0	; 63
    1882:	cd bf       	out	0x3d, r28	; 61
    1884:	cf 91       	pop	r28
    1886:	df 91       	pop	r29
    1888:	08 95       	ret

0000188a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    188a:	df 93       	push	r29
    188c:	cf 93       	push	r28
    188e:	cd b7       	in	r28, 0x3d	; 61
    1890:	de b7       	in	r29, 0x3e	; 62
    1892:	2c 97       	sbiw	r28, 0x0c	; 12
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	f8 94       	cli
    1898:	de bf       	out	0x3e, r29	; 62
    189a:	0f be       	out	0x3f, r0	; 63
    189c:	cd bf       	out	0x3d, r28	; 61
    189e:	9e 83       	std	Y+6, r25	; 0x06
    18a0:	8d 83       	std	Y+5, r24	; 0x05
    18a2:	78 87       	std	Y+8, r23	; 0x08
    18a4:	6f 83       	std	Y+7, r22	; 0x07
    18a6:	5a 87       	std	Y+10, r21	; 0x0a
    18a8:	49 87       	std	Y+9, r20	; 0x09
    18aa:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    18ac:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18b4:	ed 81       	ldd	r30, Y+5	; 0x05
    18b6:	fe 81       	ldd	r31, Y+6	; 0x06
    18b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18ba:	ed 81       	ldd	r30, Y+5	; 0x05
    18bc:	fe 81       	ldd	r31, Y+6	; 0x06
    18be:	83 8d       	ldd	r24, Z+27	; 0x1b
    18c0:	98 17       	cp	r25, r24
    18c2:	d8 f4       	brcc	.+54     	; 0x18fa <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18c4:	8d 81       	ldd	r24, Y+5	; 0x05
    18c6:	9e 81       	ldd	r25, Y+6	; 0x06
    18c8:	2f 81       	ldd	r18, Y+7	; 0x07
    18ca:	38 85       	ldd	r19, Y+8	; 0x08
    18cc:	b9 01       	movw	r22, r18
    18ce:	4b 85       	ldd	r20, Y+11	; 0x0b
    18d0:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18d4:	ed 81       	ldd	r30, Y+5	; 0x05
    18d6:	fe 81       	ldd	r31, Y+6	; 0x06
    18d8:	81 89       	ldd	r24, Z+17	; 0x11
    18da:	88 23       	and	r24, r24
    18dc:	49 f0       	breq	.+18     	; 0x18f0 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18de:	8d 81       	ldd	r24, Y+5	; 0x05
    18e0:	9e 81       	ldd	r25, Y+6	; 0x06
    18e2:	41 96       	adiw	r24, 0x11	; 17
    18e4:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    18e8:	81 30       	cpi	r24, 0x01	; 1
    18ea:	11 f4       	brne	.+4      	; 0x18f0 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    18ec:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    18f0:	0f 90       	pop	r0
    18f2:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	8c 87       	std	Y+12, r24	; 0x0c
    18f8:	5c c0       	rjmp	.+184    	; 0x19b2 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    18fa:	89 85       	ldd	r24, Y+9	; 0x09
    18fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    18fe:	00 97       	sbiw	r24, 0x00	; 0
    1900:	21 f4       	brne	.+8      	; 0x190a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1902:	0f 90       	pop	r0
    1904:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1906:	1c 86       	std	Y+12, r1	; 0x0c
    1908:	54 c0       	rjmp	.+168    	; 0x19b2 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	88 23       	and	r24, r24
    190e:	31 f4       	brne	.+12     	; 0x191c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1910:	ce 01       	movw	r24, r28
    1912:	02 96       	adiw	r24, 0x02	; 2
    1914:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1920:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	f8 94       	cli
    1928:	0f 92       	push	r0
    192a:	ed 81       	ldd	r30, Y+5	; 0x05
    192c:	fe 81       	ldd	r31, Y+6	; 0x06
    192e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1930:	8f 3f       	cpi	r24, 0xFF	; 255
    1932:	19 f4       	brne	.+6      	; 0x193a <xQueueGenericSend+0xb0>
    1934:	ed 81       	ldd	r30, Y+5	; 0x05
    1936:	fe 81       	ldd	r31, Y+6	; 0x06
    1938:	15 8e       	std	Z+29, r1	; 0x1d
    193a:	ed 81       	ldd	r30, Y+5	; 0x05
    193c:	fe 81       	ldd	r31, Y+6	; 0x06
    193e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1940:	8f 3f       	cpi	r24, 0xFF	; 255
    1942:	19 f4       	brne	.+6      	; 0x194a <xQueueGenericSend+0xc0>
    1944:	ed 81       	ldd	r30, Y+5	; 0x05
    1946:	fe 81       	ldd	r31, Y+6	; 0x06
    1948:	16 8e       	std	Z+30, r1	; 0x1e
    194a:	0f 90       	pop	r0
    194c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    194e:	ce 01       	movw	r24, r28
    1950:	02 96       	adiw	r24, 0x02	; 2
    1952:	9e 01       	movw	r18, r28
    1954:	27 5f       	subi	r18, 0xF7	; 247
    1956:	3f 4f       	sbci	r19, 0xFF	; 255
    1958:	b9 01       	movw	r22, r18
    195a:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <xTaskCheckForTimeOut>
    195e:	88 23       	and	r24, r24
    1960:	09 f5       	brne	.+66     	; 0x19a4 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1962:	8d 81       	ldd	r24, Y+5	; 0x05
    1964:	9e 81       	ldd	r25, Y+6	; 0x06
    1966:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <prvIsQueueFull>
    196a:	88 23       	and	r24, r24
    196c:	a1 f0       	breq	.+40     	; 0x1996 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    196e:	8d 81       	ldd	r24, Y+5	; 0x05
    1970:	9e 81       	ldd	r25, Y+6	; 0x06
    1972:	08 96       	adiw	r24, 0x08	; 8
    1974:	29 85       	ldd	r18, Y+9	; 0x09
    1976:	3a 85       	ldd	r19, Y+10	; 0x0a
    1978:	b9 01       	movw	r22, r18
    197a:	0e 94 5f 14 	call	0x28be	; 0x28be <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    197e:	8d 81       	ldd	r24, Y+5	; 0x05
    1980:	9e 81       	ldd	r25, Y+6	; 0x06
    1982:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1986:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    198a:	88 23       	and	r24, r24
    198c:	09 f0       	breq	.+2      	; 0x1990 <xQueueGenericSend+0x106>
    198e:	8f cf       	rjmp	.-226    	; 0x18ae <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1990:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
    1994:	8c cf       	rjmp	.-232    	; 0x18ae <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1996:	8d 81       	ldd	r24, Y+5	; 0x05
    1998:	9e 81       	ldd	r25, Y+6	; 0x06
    199a:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    199e:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    19a2:	85 cf       	rjmp	.-246    	; 0x18ae <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19a4:	8d 81       	ldd	r24, Y+5	; 0x05
    19a6:	9e 81       	ldd	r25, Y+6	; 0x06
    19a8:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ac:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19b0:	1c 86       	std	Y+12, r1	; 0x0c
    19b2:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    19b4:	2c 96       	adiw	r28, 0x0c	; 12
    19b6:	0f b6       	in	r0, 0x3f	; 63
    19b8:	f8 94       	cli
    19ba:	de bf       	out	0x3e, r29	; 62
    19bc:	0f be       	out	0x3f, r0	; 63
    19be:	cd bf       	out	0x3d, r28	; 61
    19c0:	cf 91       	pop	r28
    19c2:	df 91       	pop	r29
    19c4:	08 95       	ret

000019c6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    19c6:	df 93       	push	r29
    19c8:	cf 93       	push	r28
    19ca:	cd b7       	in	r28, 0x3d	; 61
    19cc:	de b7       	in	r29, 0x3e	; 62
    19ce:	29 97       	sbiw	r28, 0x09	; 9
    19d0:	0f b6       	in	r0, 0x3f	; 63
    19d2:	f8 94       	cli
    19d4:	de bf       	out	0x3e, r29	; 62
    19d6:	0f be       	out	0x3f, r0	; 63
    19d8:	cd bf       	out	0x3d, r28	; 61
    19da:	9c 83       	std	Y+4, r25	; 0x04
    19dc:	8b 83       	std	Y+3, r24	; 0x03
    19de:	7e 83       	std	Y+6, r23	; 0x06
    19e0:	6d 83       	std	Y+5, r22	; 0x05
    19e2:	58 87       	std	Y+8, r21	; 0x08
    19e4:	4f 83       	std	Y+7, r20	; 0x07
    19e6:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19e8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19ea:	eb 81       	ldd	r30, Y+3	; 0x03
    19ec:	fc 81       	ldd	r31, Y+4	; 0x04
    19ee:	92 8d       	ldd	r25, Z+26	; 0x1a
    19f0:	eb 81       	ldd	r30, Y+3	; 0x03
    19f2:	fc 81       	ldd	r31, Y+4	; 0x04
    19f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    19f6:	98 17       	cp	r25, r24
    19f8:	40 f5       	brcc	.+80     	; 0x1a4a <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19fa:	8b 81       	ldd	r24, Y+3	; 0x03
    19fc:	9c 81       	ldd	r25, Y+4	; 0x04
    19fe:	2d 81       	ldd	r18, Y+5	; 0x05
    1a00:	3e 81       	ldd	r19, Y+6	; 0x06
    1a02:	b9 01       	movw	r22, r18
    1a04:	49 85       	ldd	r20, Y+9	; 0x09
    1a06:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a10:	8f 3f       	cpi	r24, 0xFF	; 255
    1a12:	89 f4       	brne	.+34     	; 0x1a36 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a14:	eb 81       	ldd	r30, Y+3	; 0x03
    1a16:	fc 81       	ldd	r31, Y+4	; 0x04
    1a18:	81 89       	ldd	r24, Z+17	; 0x11
    1a1a:	88 23       	and	r24, r24
    1a1c:	99 f0       	breq	.+38     	; 0x1a44 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a20:	9c 81       	ldd	r25, Y+4	; 0x04
    1a22:	41 96       	adiw	r24, 0x11	; 17
    1a24:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1a28:	88 23       	and	r24, r24
    1a2a:	61 f0       	breq	.+24     	; 0x1a44 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1a2c:	ef 81       	ldd	r30, Y+7	; 0x07
    1a2e:	f8 85       	ldd	r31, Y+8	; 0x08
    1a30:	81 e0       	ldi	r24, 0x01	; 1
    1a32:	80 83       	st	Z, r24
    1a34:	07 c0       	rjmp	.+14     	; 0x1a44 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a36:	eb 81       	ldd	r30, Y+3	; 0x03
    1a38:	fc 81       	ldd	r31, Y+4	; 0x04
    1a3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a3c:	8f 5f       	subi	r24, 0xFF	; 255
    1a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a40:	fc 81       	ldd	r31, Y+4	; 0x04
    1a42:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a44:	81 e0       	ldi	r24, 0x01	; 1
    1a46:	8a 83       	std	Y+2, r24	; 0x02
    1a48:	01 c0       	rjmp	.+2      	; 0x1a4c <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a4a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a4c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1a4e:	29 96       	adiw	r28, 0x09	; 9
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	cf 91       	pop	r28
    1a5c:	df 91       	pop	r29
    1a5e:	08 95       	ret

00001a60 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1a60:	df 93       	push	r29
    1a62:	cf 93       	push	r28
    1a64:	cd b7       	in	r28, 0x3d	; 61
    1a66:	de b7       	in	r29, 0x3e	; 62
    1a68:	2e 97       	sbiw	r28, 0x0e	; 14
    1a6a:	0f b6       	in	r0, 0x3f	; 63
    1a6c:	f8 94       	cli
    1a6e:	de bf       	out	0x3e, r29	; 62
    1a70:	0f be       	out	0x3f, r0	; 63
    1a72:	cd bf       	out	0x3d, r28	; 61
    1a74:	98 87       	std	Y+8, r25	; 0x08
    1a76:	8f 83       	std	Y+7, r24	; 0x07
    1a78:	7a 87       	std	Y+10, r23	; 0x0a
    1a7a:	69 87       	std	Y+9, r22	; 0x09
    1a7c:	5c 87       	std	Y+12, r21	; 0x0c
    1a7e:	4b 87       	std	Y+11, r20	; 0x0b
    1a80:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1a82:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a84:	0f b6       	in	r0, 0x3f	; 63
    1a86:	f8 94       	cli
    1a88:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1a8a:	ef 81       	ldd	r30, Y+7	; 0x07
    1a8c:	f8 85       	ldd	r31, Y+8	; 0x08
    1a8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a90:	88 23       	and	r24, r24
    1a92:	09 f4       	brne	.+2      	; 0x1a96 <xQueueGenericReceive+0x36>
    1a94:	3f c0       	rjmp	.+126    	; 0x1b14 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1a96:	ef 81       	ldd	r30, Y+7	; 0x07
    1a98:	f8 85       	ldd	r31, Y+8	; 0x08
    1a9a:	86 81       	ldd	r24, Z+6	; 0x06
    1a9c:	97 81       	ldd	r25, Z+7	; 0x07
    1a9e:	9a 83       	std	Y+2, r25	; 0x02
    1aa0:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aa2:	8f 81       	ldd	r24, Y+7	; 0x07
    1aa4:	98 85       	ldd	r25, Y+8	; 0x08
    1aa6:	29 85       	ldd	r18, Y+9	; 0x09
    1aa8:	3a 85       	ldd	r19, Y+10	; 0x0a
    1aaa:	b9 01       	movw	r22, r18
    1aac:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ab0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ab2:	88 23       	and	r24, r24
    1ab4:	b1 f4       	brne	.+44     	; 0x1ae2 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1ab6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ab8:	f8 85       	ldd	r31, Y+8	; 0x08
    1aba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1abc:	81 50       	subi	r24, 0x01	; 1
    1abe:	ef 81       	ldd	r30, Y+7	; 0x07
    1ac0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ac2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ac4:	ef 81       	ldd	r30, Y+7	; 0x07
    1ac6:	f8 85       	ldd	r31, Y+8	; 0x08
    1ac8:	80 85       	ldd	r24, Z+8	; 0x08
    1aca:	88 23       	and	r24, r24
    1acc:	f1 f0       	breq	.+60     	; 0x1b0a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ace:	8f 81       	ldd	r24, Y+7	; 0x07
    1ad0:	98 85       	ldd	r25, Y+8	; 0x08
    1ad2:	08 96       	adiw	r24, 0x08	; 8
    1ad4:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1ad8:	81 30       	cpi	r24, 0x01	; 1
    1ada:	b9 f4       	brne	.+46     	; 0x1b0a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1adc:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
    1ae0:	14 c0       	rjmp	.+40     	; 0x1b0a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1ae2:	ef 81       	ldd	r30, Y+7	; 0x07
    1ae4:	f8 85       	ldd	r31, Y+8	; 0x08
    1ae6:	89 81       	ldd	r24, Y+1	; 0x01
    1ae8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aea:	97 83       	std	Z+7, r25	; 0x07
    1aec:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aee:	ef 81       	ldd	r30, Y+7	; 0x07
    1af0:	f8 85       	ldd	r31, Y+8	; 0x08
    1af2:	81 89       	ldd	r24, Z+17	; 0x11
    1af4:	88 23       	and	r24, r24
    1af6:	49 f0       	breq	.+18     	; 0x1b0a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1af8:	8f 81       	ldd	r24, Y+7	; 0x07
    1afa:	98 85       	ldd	r25, Y+8	; 0x08
    1afc:	41 96       	adiw	r24, 0x11	; 17
    1afe:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1b02:	88 23       	and	r24, r24
    1b04:	11 f0       	breq	.+4      	; 0x1b0a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1b06:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1b0a:	0f 90       	pop	r0
    1b0c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	8e 87       	std	Y+14, r24	; 0x0e
    1b12:	5c c0       	rjmp	.+184    	; 0x1bcc <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1b14:	8b 85       	ldd	r24, Y+11	; 0x0b
    1b16:	9c 85       	ldd	r25, Y+12	; 0x0c
    1b18:	00 97       	sbiw	r24, 0x00	; 0
    1b1a:	21 f4       	brne	.+8      	; 0x1b24 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b1c:	0f 90       	pop	r0
    1b1e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b20:	1e 86       	std	Y+14, r1	; 0x0e
    1b22:	54 c0       	rjmp	.+168    	; 0x1bcc <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b24:	8b 81       	ldd	r24, Y+3	; 0x03
    1b26:	88 23       	and	r24, r24
    1b28:	31 f4       	brne	.+12     	; 0x1b36 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b2a:	ce 01       	movw	r24, r28
    1b2c:	04 96       	adiw	r24, 0x04	; 4
    1b2e:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b32:	81 e0       	ldi	r24, 0x01	; 1
    1b34:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1b36:	0f 90       	pop	r0
    1b38:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b3a:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b3e:	0f b6       	in	r0, 0x3f	; 63
    1b40:	f8 94       	cli
    1b42:	0f 92       	push	r0
    1b44:	ef 81       	ldd	r30, Y+7	; 0x07
    1b46:	f8 85       	ldd	r31, Y+8	; 0x08
    1b48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b4c:	19 f4       	brne	.+6      	; 0x1b54 <xQueueGenericReceive+0xf4>
    1b4e:	ef 81       	ldd	r30, Y+7	; 0x07
    1b50:	f8 85       	ldd	r31, Y+8	; 0x08
    1b52:	15 8e       	std	Z+29, r1	; 0x1d
    1b54:	ef 81       	ldd	r30, Y+7	; 0x07
    1b56:	f8 85       	ldd	r31, Y+8	; 0x08
    1b58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5c:	19 f4       	brne	.+6      	; 0x1b64 <xQueueGenericReceive+0x104>
    1b5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1b60:	f8 85       	ldd	r31, Y+8	; 0x08
    1b62:	16 8e       	std	Z+30, r1	; 0x1e
    1b64:	0f 90       	pop	r0
    1b66:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b68:	ce 01       	movw	r24, r28
    1b6a:	04 96       	adiw	r24, 0x04	; 4
    1b6c:	9e 01       	movw	r18, r28
    1b6e:	25 5f       	subi	r18, 0xF5	; 245
    1b70:	3f 4f       	sbci	r19, 0xFF	; 255
    1b72:	b9 01       	movw	r22, r18
    1b74:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <xTaskCheckForTimeOut>
    1b78:	88 23       	and	r24, r24
    1b7a:	09 f5       	brne	.+66     	; 0x1bbe <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b7c:	8f 81       	ldd	r24, Y+7	; 0x07
    1b7e:	98 85       	ldd	r25, Y+8	; 0x08
    1b80:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <prvIsQueueEmpty>
    1b84:	88 23       	and	r24, r24
    1b86:	a1 f0       	breq	.+40     	; 0x1bb0 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b88:	8f 81       	ldd	r24, Y+7	; 0x07
    1b8a:	98 85       	ldd	r25, Y+8	; 0x08
    1b8c:	41 96       	adiw	r24, 0x11	; 17
    1b8e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1b90:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b92:	b9 01       	movw	r22, r18
    1b94:	0e 94 5f 14 	call	0x28be	; 0x28be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b98:	8f 81       	ldd	r24, Y+7	; 0x07
    1b9a:	98 85       	ldd	r25, Y+8	; 0x08
    1b9c:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ba0:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    1ba4:	88 23       	and	r24, r24
    1ba6:	09 f0       	breq	.+2      	; 0x1baa <xQueueGenericReceive+0x14a>
    1ba8:	6d cf       	rjmp	.-294    	; 0x1a84 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1baa:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
    1bae:	6a cf       	rjmp	.-300    	; 0x1a84 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bb0:	8f 81       	ldd	r24, Y+7	; 0x07
    1bb2:	98 85       	ldd	r25, Y+8	; 0x08
    1bb4:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bb8:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    1bbc:	63 cf       	rjmp	.-314    	; 0x1a84 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1bbe:	8f 81       	ldd	r24, Y+7	; 0x07
    1bc0:	98 85       	ldd	r25, Y+8	; 0x08
    1bc2:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bc6:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1bca:	1e 86       	std	Y+14, r1	; 0x0e
    1bcc:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1bce:	2e 96       	adiw	r28, 0x0e	; 14
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	de bf       	out	0x3e, r29	; 62
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	cd bf       	out	0x3d, r28	; 61
    1bda:	cf 91       	pop	r28
    1bdc:	df 91       	pop	r29
    1bde:	08 95       	ret

00001be0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1be0:	df 93       	push	r29
    1be2:	cf 93       	push	r28
    1be4:	cd b7       	in	r28, 0x3d	; 61
    1be6:	de b7       	in	r29, 0x3e	; 62
    1be8:	28 97       	sbiw	r28, 0x08	; 8
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	de bf       	out	0x3e, r29	; 62
    1bf0:	0f be       	out	0x3f, r0	; 63
    1bf2:	cd bf       	out	0x3d, r28	; 61
    1bf4:	9c 83       	std	Y+4, r25	; 0x04
    1bf6:	8b 83       	std	Y+3, r24	; 0x03
    1bf8:	7e 83       	std	Y+6, r23	; 0x06
    1bfa:	6d 83       	std	Y+5, r22	; 0x05
    1bfc:	58 87       	std	Y+8, r21	; 0x08
    1bfe:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c00:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1c02:	eb 81       	ldd	r30, Y+3	; 0x03
    1c04:	fc 81       	ldd	r31, Y+4	; 0x04
    1c06:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c08:	88 23       	and	r24, r24
    1c0a:	71 f1       	breq	.+92     	; 0x1c68 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1c0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c10:	2d 81       	ldd	r18, Y+5	; 0x05
    1c12:	3e 81       	ldd	r19, Y+6	; 0x06
    1c14:	b9 01       	movw	r22, r18
    1c16:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c20:	81 50       	subi	r24, 0x01	; 1
    1c22:	eb 81       	ldd	r30, Y+3	; 0x03
    1c24:	fc 81       	ldd	r31, Y+4	; 0x04
    1c26:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1c28:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c2e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c30:	89 f4       	brne	.+34     	; 0x1c54 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c32:	eb 81       	ldd	r30, Y+3	; 0x03
    1c34:	fc 81       	ldd	r31, Y+4	; 0x04
    1c36:	80 85       	ldd	r24, Z+8	; 0x08
    1c38:	88 23       	and	r24, r24
    1c3a:	99 f0       	breq	.+38     	; 0x1c62 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c40:	08 96       	adiw	r24, 0x08	; 8
    1c42:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1c46:	88 23       	and	r24, r24
    1c48:	61 f0       	breq	.+24     	; 0x1c62 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1c4a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c4c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	80 83       	st	Z, r24
    1c52:	07 c0       	rjmp	.+14     	; 0x1c62 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1c54:	eb 81       	ldd	r30, Y+3	; 0x03
    1c56:	fc 81       	ldd	r31, Y+4	; 0x04
    1c58:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c5a:	8f 5f       	subi	r24, 0xFF	; 255
    1c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c60:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	8a 83       	std	Y+2, r24	; 0x02
    1c66:	01 c0       	rjmp	.+2      	; 0x1c6a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1c68:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c6a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1c6c:	28 96       	adiw	r28, 0x08	; 8
    1c6e:	0f b6       	in	r0, 0x3f	; 63
    1c70:	f8 94       	cli
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	cd bf       	out	0x3d, r28	; 61
    1c78:	cf 91       	pop	r28
    1c7a:	df 91       	pop	r29
    1c7c:	08 95       	ret

00001c7e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1c7e:	df 93       	push	r29
    1c80:	cf 93       	push	r28
    1c82:	00 d0       	rcall	.+0      	; 0x1c84 <uxQueueMessagesWaiting+0x6>
    1c84:	0f 92       	push	r0
    1c86:	cd b7       	in	r28, 0x3d	; 61
    1c88:	de b7       	in	r29, 0x3e	; 62
    1c8a:	9b 83       	std	Y+3, r25	; 0x03
    1c8c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1c8e:	0f b6       	in	r0, 0x3f	; 63
    1c90:	f8 94       	cli
    1c92:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1c94:	ea 81       	ldd	r30, Y+2	; 0x02
    1c96:	fb 81       	ldd	r31, Y+3	; 0x03
    1c98:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c9a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1c9c:	0f 90       	pop	r0
    1c9e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1ca0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ca2:	0f 90       	pop	r0
    1ca4:	0f 90       	pop	r0
    1ca6:	0f 90       	pop	r0
    1ca8:	cf 91       	pop	r28
    1caa:	df 91       	pop	r29
    1cac:	08 95       	ret

00001cae <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1cae:	df 93       	push	r29
    1cb0:	cf 93       	push	r28
    1cb2:	00 d0       	rcall	.+0      	; 0x1cb4 <uxQueueMessagesWaitingFromISR+0x6>
    1cb4:	0f 92       	push	r0
    1cb6:	cd b7       	in	r28, 0x3d	; 61
    1cb8:	de b7       	in	r29, 0x3e	; 62
    1cba:	9b 83       	std	Y+3, r25	; 0x03
    1cbc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1cbe:	ea 81       	ldd	r30, Y+2	; 0x02
    1cc0:	fb 81       	ldd	r31, Y+3	; 0x03
    1cc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1cc6:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1cd4:	df 93       	push	r29
    1cd6:	cf 93       	push	r28
    1cd8:	00 d0       	rcall	.+0      	; 0x1cda <vQueueDelete+0x6>
    1cda:	cd b7       	in	r28, 0x3d	; 61
    1cdc:	de b7       	in	r29, 0x3e	; 62
    1cde:	9a 83       	std	Y+2, r25	; 0x02
    1ce0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1ce2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce6:	80 81       	ld	r24, Z
    1ce8:	91 81       	ldd	r25, Z+1	; 0x01
    1cea:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
	vPortFree( pxQueue );
    1cee:	89 81       	ldd	r24, Y+1	; 0x01
    1cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf2:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
}
    1cf6:	0f 90       	pop	r0
    1cf8:	0f 90       	pop	r0
    1cfa:	cf 91       	pop	r28
    1cfc:	df 91       	pop	r29
    1cfe:	08 95       	ret

00001d00 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1d00:	df 93       	push	r29
    1d02:	cf 93       	push	r28
    1d04:	00 d0       	rcall	.+0      	; 0x1d06 <prvCopyDataToQueue+0x6>
    1d06:	00 d0       	rcall	.+0      	; 0x1d08 <prvCopyDataToQueue+0x8>
    1d08:	0f 92       	push	r0
    1d0a:	cd b7       	in	r28, 0x3d	; 61
    1d0c:	de b7       	in	r29, 0x3e	; 62
    1d0e:	9a 83       	std	Y+2, r25	; 0x02
    1d10:	89 83       	std	Y+1, r24	; 0x01
    1d12:	7c 83       	std	Y+4, r23	; 0x04
    1d14:	6b 83       	std	Y+3, r22	; 0x03
    1d16:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1d18:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d1e:	88 23       	and	r24, r24
    1d20:	09 f4       	brne	.+2      	; 0x1d24 <prvCopyDataToQueue+0x24>
    1d22:	74 c0       	rjmp	.+232    	; 0x1e0c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1d24:	8d 81       	ldd	r24, Y+5	; 0x05
    1d26:	88 23       	and	r24, r24
    1d28:	99 f5       	brne	.+102    	; 0x1d90 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2e:	64 81       	ldd	r22, Z+4	; 0x04
    1d30:	75 81       	ldd	r23, Z+5	; 0x05
    1d32:	e9 81       	ldd	r30, Y+1	; 0x01
    1d34:	fa 81       	ldd	r31, Y+2	; 0x02
    1d36:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d38:	48 2f       	mov	r20, r24
    1d3a:	50 e0       	ldi	r21, 0x00	; 0
    1d3c:	2b 81       	ldd	r18, Y+3	; 0x03
    1d3e:	3c 81       	ldd	r19, Y+4	; 0x04
    1d40:	cb 01       	movw	r24, r22
    1d42:	b9 01       	movw	r22, r18
    1d44:	0e 94 08 17 	call	0x2e10	; 0x2e10 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1d48:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4c:	24 81       	ldd	r18, Z+4	; 0x04
    1d4e:	35 81       	ldd	r19, Z+5	; 0x05
    1d50:	e9 81       	ldd	r30, Y+1	; 0x01
    1d52:	fa 81       	ldd	r31, Y+2	; 0x02
    1d54:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d56:	88 2f       	mov	r24, r24
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	82 0f       	add	r24, r18
    1d5c:	93 1f       	adc	r25, r19
    1d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d60:	fa 81       	ldd	r31, Y+2	; 0x02
    1d62:	95 83       	std	Z+5, r25	; 0x05
    1d64:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	24 81       	ldd	r18, Z+4	; 0x04
    1d6c:	35 81       	ldd	r19, Z+5	; 0x05
    1d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d70:	fa 81       	ldd	r31, Y+2	; 0x02
    1d72:	82 81       	ldd	r24, Z+2	; 0x02
    1d74:	93 81       	ldd	r25, Z+3	; 0x03
    1d76:	28 17       	cp	r18, r24
    1d78:	39 07       	cpc	r19, r25
    1d7a:	08 f4       	brcc	.+2      	; 0x1d7e <prvCopyDataToQueue+0x7e>
    1d7c:	47 c0       	rjmp	.+142    	; 0x1e0c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1d7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d80:	fa 81       	ldd	r31, Y+2	; 0x02
    1d82:	80 81       	ld	r24, Z
    1d84:	91 81       	ldd	r25, Z+1	; 0x01
    1d86:	e9 81       	ldd	r30, Y+1	; 0x01
    1d88:	fa 81       	ldd	r31, Y+2	; 0x02
    1d8a:	95 83       	std	Z+5, r25	; 0x05
    1d8c:	84 83       	std	Z+4, r24	; 0x04
    1d8e:	3e c0       	rjmp	.+124    	; 0x1e0c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1d90:	e9 81       	ldd	r30, Y+1	; 0x01
    1d92:	fa 81       	ldd	r31, Y+2	; 0x02
    1d94:	66 81       	ldd	r22, Z+6	; 0x06
    1d96:	77 81       	ldd	r23, Z+7	; 0x07
    1d98:	e9 81       	ldd	r30, Y+1	; 0x01
    1d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d9e:	48 2f       	mov	r20, r24
    1da0:	50 e0       	ldi	r21, 0x00	; 0
    1da2:	2b 81       	ldd	r18, Y+3	; 0x03
    1da4:	3c 81       	ldd	r19, Y+4	; 0x04
    1da6:	cb 01       	movw	r24, r22
    1da8:	b9 01       	movw	r22, r18
    1daa:	0e 94 08 17 	call	0x2e10	; 0x2e10 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1dae:	e9 81       	ldd	r30, Y+1	; 0x01
    1db0:	fa 81       	ldd	r31, Y+2	; 0x02
    1db2:	26 81       	ldd	r18, Z+6	; 0x06
    1db4:	37 81       	ldd	r19, Z+7	; 0x07
    1db6:	e9 81       	ldd	r30, Y+1	; 0x01
    1db8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dba:	84 8d       	ldd	r24, Z+28	; 0x1c
    1dbc:	88 2f       	mov	r24, r24
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	90 95       	com	r25
    1dc2:	81 95       	neg	r24
    1dc4:	9f 4f       	sbci	r25, 0xFF	; 255
    1dc6:	82 0f       	add	r24, r18
    1dc8:	93 1f       	adc	r25, r19
    1dca:	e9 81       	ldd	r30, Y+1	; 0x01
    1dcc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dce:	97 83       	std	Z+7, r25	; 0x07
    1dd0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1dd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd6:	26 81       	ldd	r18, Z+6	; 0x06
    1dd8:	37 81       	ldd	r19, Z+7	; 0x07
    1dda:	e9 81       	ldd	r30, Y+1	; 0x01
    1ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dde:	80 81       	ld	r24, Z
    1de0:	91 81       	ldd	r25, Z+1	; 0x01
    1de2:	28 17       	cp	r18, r24
    1de4:	39 07       	cpc	r19, r25
    1de6:	90 f4       	brcc	.+36     	; 0x1e0c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1de8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dea:	fa 81       	ldd	r31, Y+2	; 0x02
    1dec:	22 81       	ldd	r18, Z+2	; 0x02
    1dee:	33 81       	ldd	r19, Z+3	; 0x03
    1df0:	e9 81       	ldd	r30, Y+1	; 0x01
    1df2:	fa 81       	ldd	r31, Y+2	; 0x02
    1df4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1df6:	88 2f       	mov	r24, r24
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	90 95       	com	r25
    1dfc:	81 95       	neg	r24
    1dfe:	9f 4f       	sbci	r25, 0xFF	; 255
    1e00:	82 0f       	add	r24, r18
    1e02:	93 1f       	adc	r25, r19
    1e04:	e9 81       	ldd	r30, Y+1	; 0x01
    1e06:	fa 81       	ldd	r31, Y+2	; 0x02
    1e08:	97 83       	std	Z+7, r25	; 0x07
    1e0a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e10:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e12:	8f 5f       	subi	r24, 0xFF	; 255
    1e14:	e9 81       	ldd	r30, Y+1	; 0x01
    1e16:	fa 81       	ldd	r31, Y+2	; 0x02
    1e18:	82 8f       	std	Z+26, r24	; 0x1a
}
    1e1a:	0f 90       	pop	r0
    1e1c:	0f 90       	pop	r0
    1e1e:	0f 90       	pop	r0
    1e20:	0f 90       	pop	r0
    1e22:	0f 90       	pop	r0
    1e24:	cf 91       	pop	r28
    1e26:	df 91       	pop	r29
    1e28:	08 95       	ret

00001e2a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1e2a:	df 93       	push	r29
    1e2c:	cf 93       	push	r28
    1e2e:	00 d0       	rcall	.+0      	; 0x1e30 <prvCopyDataFromQueue+0x6>
    1e30:	00 d0       	rcall	.+0      	; 0x1e32 <prvCopyDataFromQueue+0x8>
    1e32:	cd b7       	in	r28, 0x3d	; 61
    1e34:	de b7       	in	r29, 0x3e	; 62
    1e36:	9a 83       	std	Y+2, r25	; 0x02
    1e38:	89 83       	std	Y+1, r24	; 0x01
    1e3a:	7c 83       	std	Y+4, r23	; 0x04
    1e3c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e40:	fa 81       	ldd	r31, Y+2	; 0x02
    1e42:	80 81       	ld	r24, Z
    1e44:	91 81       	ldd	r25, Z+1	; 0x01
    1e46:	00 97       	sbiw	r24, 0x00	; 0
    1e48:	89 f1       	breq	.+98     	; 0x1eac <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4e:	26 81       	ldd	r18, Z+6	; 0x06
    1e50:	37 81       	ldd	r19, Z+7	; 0x07
    1e52:	e9 81       	ldd	r30, Y+1	; 0x01
    1e54:	fa 81       	ldd	r31, Y+2	; 0x02
    1e56:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e58:	88 2f       	mov	r24, r24
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	82 0f       	add	r24, r18
    1e5e:	93 1f       	adc	r25, r19
    1e60:	e9 81       	ldd	r30, Y+1	; 0x01
    1e62:	fa 81       	ldd	r31, Y+2	; 0x02
    1e64:	97 83       	std	Z+7, r25	; 0x07
    1e66:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1e68:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6c:	26 81       	ldd	r18, Z+6	; 0x06
    1e6e:	37 81       	ldd	r19, Z+7	; 0x07
    1e70:	e9 81       	ldd	r30, Y+1	; 0x01
    1e72:	fa 81       	ldd	r31, Y+2	; 0x02
    1e74:	82 81       	ldd	r24, Z+2	; 0x02
    1e76:	93 81       	ldd	r25, Z+3	; 0x03
    1e78:	28 17       	cp	r18, r24
    1e7a:	39 07       	cpc	r19, r25
    1e7c:	40 f0       	brcs	.+16     	; 0x1e8e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e80:	fa 81       	ldd	r31, Y+2	; 0x02
    1e82:	80 81       	ld	r24, Z
    1e84:	91 81       	ldd	r25, Z+1	; 0x01
    1e86:	e9 81       	ldd	r30, Y+1	; 0x01
    1e88:	fa 81       	ldd	r31, Y+2	; 0x02
    1e8a:	97 83       	std	Z+7, r25	; 0x07
    1e8c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1e8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e90:	fa 81       	ldd	r31, Y+2	; 0x02
    1e92:	46 81       	ldd	r20, Z+6	; 0x06
    1e94:	57 81       	ldd	r21, Z+7	; 0x07
    1e96:	e9 81       	ldd	r30, Y+1	; 0x01
    1e98:	fa 81       	ldd	r31, Y+2	; 0x02
    1e9a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e9c:	28 2f       	mov	r18, r24
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea4:	ba 01       	movw	r22, r20
    1ea6:	a9 01       	movw	r20, r18
    1ea8:	0e 94 08 17 	call	0x2e10	; 0x2e10 <memcpy>
	}
}
    1eac:	0f 90       	pop	r0
    1eae:	0f 90       	pop	r0
    1eb0:	0f 90       	pop	r0
    1eb2:	0f 90       	pop	r0
    1eb4:	cf 91       	pop	r28
    1eb6:	df 91       	pop	r29
    1eb8:	08 95       	ret

00001eba <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1eba:	df 93       	push	r29
    1ebc:	cf 93       	push	r28
    1ebe:	00 d0       	rcall	.+0      	; 0x1ec0 <prvUnlockQueue+0x6>
    1ec0:	cd b7       	in	r28, 0x3d	; 61
    1ec2:	de b7       	in	r29, 0x3e	; 62
    1ec4:	9a 83       	std	Y+2, r25	; 0x02
    1ec6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1ec8:	0f b6       	in	r0, 0x3f	; 63
    1eca:	f8 94       	cli
    1ecc:	0f 92       	push	r0
    1ece:	15 c0       	rjmp	.+42     	; 0x1efa <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed4:	81 89       	ldd	r24, Z+17	; 0x11
    1ed6:	88 23       	and	r24, r24
    1ed8:	a9 f0       	breq	.+42     	; 0x1f04 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eda:	89 81       	ldd	r24, Y+1	; 0x01
    1edc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ede:	41 96       	adiw	r24, 0x11	; 17
    1ee0:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1ee4:	88 23       	and	r24, r24
    1ee6:	11 f0       	breq	.+4      	; 0x1eec <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1ee8:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1eec:	e9 81       	ldd	r30, Y+1	; 0x01
    1eee:	fa 81       	ldd	r31, Y+2	; 0x02
    1ef0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ef2:	81 50       	subi	r24, 0x01	; 1
    1ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ef8:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1efa:	e9 81       	ldd	r30, Y+1	; 0x01
    1efc:	fa 81       	ldd	r31, Y+2	; 0x02
    1efe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f00:	18 16       	cp	r1, r24
    1f02:	34 f3       	brlt	.-52     	; 0x1ed0 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1f04:	e9 81       	ldd	r30, Y+1	; 0x01
    1f06:	fa 81       	ldd	r31, Y+2	; 0x02
    1f08:	8f ef       	ldi	r24, 0xFF	; 255
    1f0a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1f0c:	0f 90       	pop	r0
    1f0e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	0f 92       	push	r0
    1f16:	15 c0       	rjmp	.+42     	; 0x1f42 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	80 85       	ldd	r24, Z+8	; 0x08
    1f1e:	88 23       	and	r24, r24
    1f20:	a9 f0       	breq	.+42     	; 0x1f4c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f22:	89 81       	ldd	r24, Y+1	; 0x01
    1f24:	9a 81       	ldd	r25, Y+2	; 0x02
    1f26:	08 96       	adiw	r24, 0x08	; 8
    1f28:	0e 94 95 14 	call	0x292a	; 0x292a <xTaskRemoveFromEventList>
    1f2c:	88 23       	and	r24, r24
    1f2e:	11 f0       	breq	.+4      	; 0x1f34 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1f30:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1f34:	e9 81       	ldd	r30, Y+1	; 0x01
    1f36:	fa 81       	ldd	r31, Y+2	; 0x02
    1f38:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f3a:	81 50       	subi	r24, 0x01	; 1
    1f3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f40:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1f42:	e9 81       	ldd	r30, Y+1	; 0x01
    1f44:	fa 81       	ldd	r31, Y+2	; 0x02
    1f46:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f48:	18 16       	cp	r1, r24
    1f4a:	34 f3       	brlt	.-52     	; 0x1f18 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	8f ef       	ldi	r24, 0xFF	; 255
    1f52:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1f54:	0f 90       	pop	r0
    1f56:	0f be       	out	0x3f, r0	; 63
}
    1f58:	0f 90       	pop	r0
    1f5a:	0f 90       	pop	r0
    1f5c:	cf 91       	pop	r28
    1f5e:	df 91       	pop	r29
    1f60:	08 95       	ret

00001f62 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1f62:	df 93       	push	r29
    1f64:	cf 93       	push	r28
    1f66:	00 d0       	rcall	.+0      	; 0x1f68 <prvIsQueueEmpty+0x6>
    1f68:	0f 92       	push	r0
    1f6a:	cd b7       	in	r28, 0x3d	; 61
    1f6c:	de b7       	in	r29, 0x3e	; 62
    1f6e:	9b 83       	std	Y+3, r25	; 0x03
    1f70:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1f72:	0f b6       	in	r0, 0x3f	; 63
    1f74:	f8 94       	cli
    1f76:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1f78:	ea 81       	ldd	r30, Y+2	; 0x02
    1f7a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f7e:	19 82       	std	Y+1, r1	; 0x01
    1f80:	88 23       	and	r24, r24
    1f82:	11 f4       	brne	.+4      	; 0x1f88 <prvIsQueueEmpty+0x26>
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1f88:	0f 90       	pop	r0
    1f8a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1f8c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f8e:	0f 90       	pop	r0
    1f90:	0f 90       	pop	r0
    1f92:	0f 90       	pop	r0
    1f94:	cf 91       	pop	r28
    1f96:	df 91       	pop	r29
    1f98:	08 95       	ret

00001f9a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1f9a:	df 93       	push	r29
    1f9c:	cf 93       	push	r28
    1f9e:	00 d0       	rcall	.+0      	; 0x1fa0 <xQueueIsQueueEmptyFromISR+0x6>
    1fa0:	0f 92       	push	r0
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	9b 83       	std	Y+3, r25	; 0x03
    1fa8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1faa:	ea 81       	ldd	r30, Y+2	; 0x02
    1fac:	fb 81       	ldd	r31, Y+3	; 0x03
    1fae:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb0:	19 82       	std	Y+1, r1	; 0x01
    1fb2:	88 23       	and	r24, r24
    1fb4:	11 f4       	brne	.+4      	; 0x1fba <xQueueIsQueueEmptyFromISR+0x20>
    1fb6:	81 e0       	ldi	r24, 0x01	; 1
    1fb8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1fba:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fbc:	0f 90       	pop	r0
    1fbe:	0f 90       	pop	r0
    1fc0:	0f 90       	pop	r0
    1fc2:	cf 91       	pop	r28
    1fc4:	df 91       	pop	r29
    1fc6:	08 95       	ret

00001fc8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1fc8:	df 93       	push	r29
    1fca:	cf 93       	push	r28
    1fcc:	00 d0       	rcall	.+0      	; 0x1fce <prvIsQueueFull+0x6>
    1fce:	0f 92       	push	r0
    1fd0:	cd b7       	in	r28, 0x3d	; 61
    1fd2:	de b7       	in	r29, 0x3e	; 62
    1fd4:	9b 83       	std	Y+3, r25	; 0x03
    1fd6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1fde:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe0:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe2:	92 8d       	ldd	r25, Z+26	; 0x1a
    1fe4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fea:	19 82       	std	Y+1, r1	; 0x01
    1fec:	98 17       	cp	r25, r24
    1fee:	11 f4       	brne	.+4      	; 0x1ff4 <prvIsQueueFull+0x2c>
    1ff0:	81 e0       	ldi	r24, 0x01	; 1
    1ff2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	cf 91       	pop	r28
    2002:	df 91       	pop	r29
    2004:	08 95       	ret

00002006 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2006:	df 93       	push	r29
    2008:	cf 93       	push	r28
    200a:	00 d0       	rcall	.+0      	; 0x200c <xQueueIsQueueFullFromISR+0x6>
    200c:	0f 92       	push	r0
    200e:	cd b7       	in	r28, 0x3d	; 61
    2010:	de b7       	in	r29, 0x3e	; 62
    2012:	9b 83       	std	Y+3, r25	; 0x03
    2014:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2016:	ea 81       	ldd	r30, Y+2	; 0x02
    2018:	fb 81       	ldd	r31, Y+3	; 0x03
    201a:	92 8d       	ldd	r25, Z+26	; 0x1a
    201c:	ea 81       	ldd	r30, Y+2	; 0x02
    201e:	fb 81       	ldd	r31, Y+3	; 0x03
    2020:	83 8d       	ldd	r24, Z+27	; 0x1b
    2022:	19 82       	std	Y+1, r1	; 0x01
    2024:	98 17       	cp	r25, r24
    2026:	11 f4       	brne	.+4      	; 0x202c <xQueueIsQueueFullFromISR+0x26>
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    202c:	89 81       	ldd	r24, Y+1	; 0x01
}
    202e:	0f 90       	pop	r0
    2030:	0f 90       	pop	r0
    2032:	0f 90       	pop	r0
    2034:	cf 91       	pop	r28
    2036:	df 91       	pop	r29
    2038:	08 95       	ret

0000203a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    203a:	af 92       	push	r10
    203c:	bf 92       	push	r11
    203e:	cf 92       	push	r12
    2040:	df 92       	push	r13
    2042:	ef 92       	push	r14
    2044:	ff 92       	push	r15
    2046:	0f 93       	push	r16
    2048:	1f 93       	push	r17
    204a:	df 93       	push	r29
    204c:	cf 93       	push	r28
    204e:	cd b7       	in	r28, 0x3d	; 61
    2050:	de b7       	in	r29, 0x3e	; 62
    2052:	64 97       	sbiw	r28, 0x14	; 20
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	9f 83       	std	Y+7, r25	; 0x07
    2060:	8e 83       	std	Y+6, r24	; 0x06
    2062:	79 87       	std	Y+9, r23	; 0x09
    2064:	68 87       	std	Y+8, r22	; 0x08
    2066:	5b 87       	std	Y+11, r21	; 0x0b
    2068:	4a 87       	std	Y+10, r20	; 0x0a
    206a:	3d 87       	std	Y+13, r19	; 0x0d
    206c:	2c 87       	std	Y+12, r18	; 0x0c
    206e:	0e 87       	std	Y+14, r16	; 0x0e
    2070:	f8 8a       	std	Y+16, r15	; 0x10
    2072:	ef 86       	std	Y+15, r14	; 0x0f
    2074:	da 8a       	std	Y+18, r13	; 0x12
    2076:	c9 8a       	std	Y+17, r12	; 0x11
    2078:	bc 8a       	std	Y+20, r11	; 0x14
    207a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    207c:	8a 85       	ldd	r24, Y+10	; 0x0a
    207e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2080:	29 89       	ldd	r18, Y+17	; 0x11
    2082:	3a 89       	ldd	r19, Y+18	; 0x12
    2084:	b9 01       	movw	r22, r18
    2086:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <prvAllocateTCBAndStack>
    208a:	9c 83       	std	Y+4, r25	; 0x04
    208c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    208e:	8b 81       	ldd	r24, Y+3	; 0x03
    2090:	9c 81       	ldd	r25, Y+4	; 0x04
    2092:	00 97       	sbiw	r24, 0x00	; 0
    2094:	09 f4       	brne	.+2      	; 0x2098 <xTaskGenericCreate+0x5e>
    2096:	99 c0       	rjmp	.+306    	; 0x21ca <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2098:	eb 81       	ldd	r30, Y+3	; 0x03
    209a:	fc 81       	ldd	r31, Y+4	; 0x04
    209c:	27 89       	ldd	r18, Z+23	; 0x17
    209e:	30 8d       	ldd	r19, Z+24	; 0x18
    20a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    20a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    20a4:	01 97       	sbiw	r24, 0x01	; 1
    20a6:	82 0f       	add	r24, r18
    20a8:	93 1f       	adc	r25, r19
    20aa:	9a 83       	std	Y+2, r25	; 0x02
    20ac:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    20ae:	8b 81       	ldd	r24, Y+3	; 0x03
    20b0:	9c 81       	ldd	r25, Y+4	; 0x04
    20b2:	28 85       	ldd	r18, Y+8	; 0x08
    20b4:	39 85       	ldd	r19, Y+9	; 0x09
    20b6:	eb 89       	ldd	r30, Y+19	; 0x13
    20b8:	fc 89       	ldd	r31, Y+20	; 0x14
    20ba:	aa 85       	ldd	r26, Y+10	; 0x0a
    20bc:	bb 85       	ldd	r27, Y+11	; 0x0b
    20be:	b9 01       	movw	r22, r18
    20c0:	4e 85       	ldd	r20, Y+14	; 0x0e
    20c2:	9f 01       	movw	r18, r30
    20c4:	8d 01       	movw	r16, r26
    20c6:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    20ca:	89 81       	ldd	r24, Y+1	; 0x01
    20cc:	9a 81       	ldd	r25, Y+2	; 0x02
    20ce:	2e 81       	ldd	r18, Y+6	; 0x06
    20d0:	3f 81       	ldd	r19, Y+7	; 0x07
    20d2:	4c 85       	ldd	r20, Y+12	; 0x0c
    20d4:	5d 85       	ldd	r21, Y+13	; 0x0d
    20d6:	b9 01       	movw	r22, r18
    20d8:	0e 94 ca 08 	call	0x1194	; 0x1194 <pxPortInitialiseStack>
    20dc:	eb 81       	ldd	r30, Y+3	; 0x03
    20de:	fc 81       	ldd	r31, Y+4	; 0x04
    20e0:	91 83       	std	Z+1, r25	; 0x01
    20e2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    20e4:	8f 85       	ldd	r24, Y+15	; 0x0f
    20e6:	98 89       	ldd	r25, Y+16	; 0x10
    20e8:	00 97       	sbiw	r24, 0x00	; 0
    20ea:	31 f0       	breq	.+12     	; 0x20f8 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    20ec:	ef 85       	ldd	r30, Y+15	; 0x0f
    20ee:	f8 89       	ldd	r31, Y+16	; 0x10
    20f0:	8b 81       	ldd	r24, Y+3	; 0x03
    20f2:	9c 81       	ldd	r25, Y+4	; 0x04
    20f4:	91 83       	std	Z+1, r25	; 0x01
    20f6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    20fe:	80 91 ff 02 	lds	r24, 0x02FF
    2102:	8f 5f       	subi	r24, 0xFF	; 255
    2104:	80 93 ff 02 	sts	0x02FF, r24
			if( pxCurrentTCB == NULL )
    2108:	80 91 fc 02 	lds	r24, 0x02FC
    210c:	90 91 fd 02 	lds	r25, 0x02FD
    2110:	00 97       	sbiw	r24, 0x00	; 0
    2112:	69 f4       	brne	.+26     	; 0x212e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2114:	8b 81       	ldd	r24, Y+3	; 0x03
    2116:	9c 81       	ldd	r25, Y+4	; 0x04
    2118:	90 93 fd 02 	sts	0x02FD, r25
    211c:	80 93 fc 02 	sts	0x02FC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2120:	80 91 ff 02 	lds	r24, 0x02FF
    2124:	81 30       	cpi	r24, 0x01	; 1
    2126:	a9 f4       	brne	.+42     	; 0x2152 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2128:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <prvInitialiseTaskLists>
    212c:	12 c0       	rjmp	.+36     	; 0x2152 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    212e:	80 91 04 03 	lds	r24, 0x0304
    2132:	88 23       	and	r24, r24
    2134:	71 f4       	brne	.+28     	; 0x2152 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2136:	e0 91 fc 02 	lds	r30, 0x02FC
    213a:	f0 91 fd 02 	lds	r31, 0x02FD
    213e:	96 89       	ldd	r25, Z+22	; 0x16
    2140:	8e 85       	ldd	r24, Y+14	; 0x0e
    2142:	89 17       	cp	r24, r25
    2144:	30 f0       	brcs	.+12     	; 0x2152 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2146:	8b 81       	ldd	r24, Y+3	; 0x03
    2148:	9c 81       	ldd	r25, Y+4	; 0x04
    214a:	90 93 fd 02 	sts	0x02FD, r25
    214e:	80 93 fc 02 	sts	0x02FC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2152:	eb 81       	ldd	r30, Y+3	; 0x03
    2154:	fc 81       	ldd	r31, Y+4	; 0x04
    2156:	96 89       	ldd	r25, Z+22	; 0x16
    2158:	80 91 02 03 	lds	r24, 0x0302
    215c:	89 17       	cp	r24, r25
    215e:	28 f4       	brcc	.+10     	; 0x216a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2160:	eb 81       	ldd	r30, Y+3	; 0x03
    2162:	fc 81       	ldd	r31, Y+4	; 0x04
    2164:	86 89       	ldd	r24, Z+22	; 0x16
    2166:	80 93 02 03 	sts	0x0302, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    216a:	80 91 09 03 	lds	r24, 0x0309
    216e:	8f 5f       	subi	r24, 0xFF	; 255
    2170:	80 93 09 03 	sts	0x0309, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2174:	eb 81       	ldd	r30, Y+3	; 0x03
    2176:	fc 81       	ldd	r31, Y+4	; 0x04
    2178:	96 89       	ldd	r25, Z+22	; 0x16
    217a:	80 91 03 03 	lds	r24, 0x0303
    217e:	89 17       	cp	r24, r25
    2180:	28 f4       	brcc	.+10     	; 0x218c <xTaskGenericCreate+0x152>
    2182:	eb 81       	ldd	r30, Y+3	; 0x03
    2184:	fc 81       	ldd	r31, Y+4	; 0x04
    2186:	86 89       	ldd	r24, Z+22	; 0x16
    2188:	80 93 03 03 	sts	0x0303, r24
    218c:	eb 81       	ldd	r30, Y+3	; 0x03
    218e:	fc 81       	ldd	r31, Y+4	; 0x04
    2190:	86 89       	ldd	r24, Z+22	; 0x16
    2192:	28 2f       	mov	r18, r24
    2194:	30 e0       	ldi	r19, 0x00	; 0
    2196:	c9 01       	movw	r24, r18
    2198:	88 0f       	add	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	88 0f       	add	r24, r24
    219e:	99 1f       	adc	r25, r25
    21a0:	88 0f       	add	r24, r24
    21a2:	99 1f       	adc	r25, r25
    21a4:	82 0f       	add	r24, r18
    21a6:	93 1f       	adc	r25, r19
    21a8:	ac 01       	movw	r20, r24
    21aa:	46 5f       	subi	r20, 0xF6	; 246
    21ac:	5c 4f       	sbci	r21, 0xFC	; 252
    21ae:	8b 81       	ldd	r24, Y+3	; 0x03
    21b0:	9c 81       	ldd	r25, Y+4	; 0x04
    21b2:	9c 01       	movw	r18, r24
    21b4:	2e 5f       	subi	r18, 0xFE	; 254
    21b6:	3f 4f       	sbci	r19, 0xFF	; 255
    21b8:	ca 01       	movw	r24, r20
    21ba:	b9 01       	movw	r22, r18
    21bc:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>

			xReturn = pdPASS;
    21c0:	81 e0       	ldi	r24, 0x01	; 1
    21c2:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    21c4:	0f 90       	pop	r0
    21c6:	0f be       	out	0x3f, r0	; 63
    21c8:	02 c0       	rjmp	.+4      	; 0x21ce <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    21ca:	8f ef       	ldi	r24, 0xFF	; 255
    21cc:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    21ce:	8d 81       	ldd	r24, Y+5	; 0x05
    21d0:	81 30       	cpi	r24, 0x01	; 1
    21d2:	71 f4       	brne	.+28     	; 0x21f0 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    21d4:	80 91 04 03 	lds	r24, 0x0304
    21d8:	88 23       	and	r24, r24
    21da:	51 f0       	breq	.+20     	; 0x21f0 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    21dc:	e0 91 fc 02 	lds	r30, 0x02FC
    21e0:	f0 91 fd 02 	lds	r31, 0x02FD
    21e4:	96 89       	ldd	r25, Z+22	; 0x16
    21e6:	8e 85       	ldd	r24, Y+14	; 0x0e
    21e8:	98 17       	cp	r25, r24
    21ea:	10 f4       	brcc	.+4      	; 0x21f0 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    21ec:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
			}
		}
	}

	return xReturn;
    21f0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    21f2:	64 96       	adiw	r28, 0x14	; 20
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	cd bf       	out	0x3d, r28	; 61
    21fe:	cf 91       	pop	r28
    2200:	df 91       	pop	r29
    2202:	1f 91       	pop	r17
    2204:	0f 91       	pop	r16
    2206:	ff 90       	pop	r15
    2208:	ef 90       	pop	r14
    220a:	df 90       	pop	r13
    220c:	cf 90       	pop	r12
    220e:	bf 90       	pop	r11
    2210:	af 90       	pop	r10
    2212:	08 95       	ret

00002214 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2214:	df 93       	push	r29
    2216:	cf 93       	push	r28
    2218:	00 d0       	rcall	.+0      	; 0x221a <vTaskDelete+0x6>
    221a:	00 d0       	rcall	.+0      	; 0x221c <vTaskDelete+0x8>
    221c:	00 d0       	rcall	.+0      	; 0x221e <vTaskDelete+0xa>
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
    2222:	9c 83       	std	Y+4, r25	; 0x04
    2224:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2226:	0f b6       	in	r0, 0x3f	; 63
    2228:	f8 94       	cli
    222a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    222c:	20 91 fc 02 	lds	r18, 0x02FC
    2230:	30 91 fd 02 	lds	r19, 0x02FD
    2234:	8b 81       	ldd	r24, Y+3	; 0x03
    2236:	9c 81       	ldd	r25, Y+4	; 0x04
    2238:	82 17       	cp	r24, r18
    223a:	93 07       	cpc	r25, r19
    223c:	11 f4       	brne	.+4      	; 0x2242 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    223e:	1c 82       	std	Y+4, r1	; 0x04
    2240:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	00 97       	sbiw	r24, 0x00	; 0
    2248:	39 f4       	brne	.+14     	; 0x2258 <vTaskDelete+0x44>
    224a:	80 91 fc 02 	lds	r24, 0x02FC
    224e:	90 91 fd 02 	lds	r25, 0x02FD
    2252:	9e 83       	std	Y+6, r25	; 0x06
    2254:	8d 83       	std	Y+5, r24	; 0x05
    2256:	04 c0       	rjmp	.+8      	; 0x2260 <vTaskDelete+0x4c>
    2258:	8b 81       	ldd	r24, Y+3	; 0x03
    225a:	9c 81       	ldd	r25, Y+4	; 0x04
    225c:	9e 83       	std	Y+6, r25	; 0x06
    225e:	8d 83       	std	Y+5, r24	; 0x05
    2260:	8d 81       	ldd	r24, Y+5	; 0x05
    2262:	9e 81       	ldd	r25, Y+6	; 0x06
    2264:	9a 83       	std	Y+2, r25	; 0x02
    2266:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2268:	89 81       	ldd	r24, Y+1	; 0x01
    226a:	9a 81       	ldd	r25, Y+2	; 0x02
    226c:	02 96       	adiw	r24, 0x02	; 2
    226e:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2272:	e9 81       	ldd	r30, Y+1	; 0x01
    2274:	fa 81       	ldd	r31, Y+2	; 0x02
    2276:	84 89       	ldd	r24, Z+20	; 0x14
    2278:	95 89       	ldd	r25, Z+21	; 0x15
    227a:	00 97       	sbiw	r24, 0x00	; 0
    227c:	29 f0       	breq	.+10     	; 0x2288 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    227e:	89 81       	ldd	r24, Y+1	; 0x01
    2280:	9a 81       	ldd	r25, Y+2	; 0x02
    2282:	0c 96       	adiw	r24, 0x0c	; 12
    2284:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	9a 81       	ldd	r25, Y+2	; 0x02
    228c:	9c 01       	movw	r18, r24
    228e:	2e 5f       	subi	r18, 0xFE	; 254
    2290:	3f 4f       	sbci	r19, 0xFF	; 255
    2292:	86 e5       	ldi	r24, 0x56	; 86
    2294:	93 e0       	ldi	r25, 0x03	; 3
    2296:	b9 01       	movw	r22, r18
    2298:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    229c:	80 91 fe 02 	lds	r24, 0x02FE
    22a0:	8f 5f       	subi	r24, 0xFF	; 255
    22a2:	80 93 fe 02 	sts	0x02FE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    22a6:	80 91 09 03 	lds	r24, 0x0309
    22aa:	8f 5f       	subi	r24, 0xFF	; 255
    22ac:	80 93 09 03 	sts	0x0309, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    22b0:	0f 90       	pop	r0
    22b2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    22b4:	80 91 04 03 	lds	r24, 0x0304
    22b8:	88 23       	and	r24, r24
    22ba:	31 f0       	breq	.+12     	; 0x22c8 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    22bc:	8b 81       	ldd	r24, Y+3	; 0x03
    22be:	9c 81       	ldd	r25, Y+4	; 0x04
    22c0:	00 97       	sbiw	r24, 0x00	; 0
    22c2:	11 f4       	brne	.+4      	; 0x22c8 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    22c4:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
			}
		}
	}
    22c8:	26 96       	adiw	r28, 0x06	; 6
    22ca:	0f b6       	in	r0, 0x3f	; 63
    22cc:	f8 94       	cli
    22ce:	de bf       	out	0x3e, r29	; 62
    22d0:	0f be       	out	0x3f, r0	; 63
    22d2:	cd bf       	out	0x3d, r28	; 61
    22d4:	cf 91       	pop	r28
    22d6:	df 91       	pop	r29
    22d8:	08 95       	ret

000022da <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    22da:	df 93       	push	r29
    22dc:	cf 93       	push	r28
    22de:	cd b7       	in	r28, 0x3d	; 61
    22e0:	de b7       	in	r29, 0x3e	; 62
    22e2:	28 97       	sbiw	r28, 0x08	; 8
    22e4:	0f b6       	in	r0, 0x3f	; 63
    22e6:	f8 94       	cli
    22e8:	de bf       	out	0x3e, r29	; 62
    22ea:	0f be       	out	0x3f, r0	; 63
    22ec:	cd bf       	out	0x3d, r28	; 61
    22ee:	9e 83       	std	Y+6, r25	; 0x06
    22f0:	8d 83       	std	Y+5, r24	; 0x05
    22f2:	78 87       	std	Y+8, r23	; 0x08
    22f4:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    22f6:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    22f8:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    22fc:	ed 81       	ldd	r30, Y+5	; 0x05
    22fe:	fe 81       	ldd	r31, Y+6	; 0x06
    2300:	20 81       	ld	r18, Z
    2302:	31 81       	ldd	r19, Z+1	; 0x01
    2304:	8f 81       	ldd	r24, Y+7	; 0x07
    2306:	98 85       	ldd	r25, Y+8	; 0x08
    2308:	82 0f       	add	r24, r18
    230a:	93 1f       	adc	r25, r19
    230c:	9c 83       	std	Y+4, r25	; 0x04
    230e:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2310:	ed 81       	ldd	r30, Y+5	; 0x05
    2312:	fe 81       	ldd	r31, Y+6	; 0x06
    2314:	20 81       	ld	r18, Z
    2316:	31 81       	ldd	r19, Z+1	; 0x01
    2318:	80 91 00 03 	lds	r24, 0x0300
    231c:	90 91 01 03 	lds	r25, 0x0301
    2320:	82 17       	cp	r24, r18
    2322:	93 07       	cpc	r25, r19
    2324:	a8 f4       	brcc	.+42     	; 0x2350 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2326:	ed 81       	ldd	r30, Y+5	; 0x05
    2328:	fe 81       	ldd	r31, Y+6	; 0x06
    232a:	20 81       	ld	r18, Z
    232c:	31 81       	ldd	r19, Z+1	; 0x01
    232e:	8b 81       	ldd	r24, Y+3	; 0x03
    2330:	9c 81       	ldd	r25, Y+4	; 0x04
    2332:	82 17       	cp	r24, r18
    2334:	93 07       	cpc	r25, r19
    2336:	00 f5       	brcc	.+64     	; 0x2378 <vTaskDelayUntil+0x9e>
    2338:	20 91 00 03 	lds	r18, 0x0300
    233c:	30 91 01 03 	lds	r19, 0x0301
    2340:	8b 81       	ldd	r24, Y+3	; 0x03
    2342:	9c 81       	ldd	r25, Y+4	; 0x04
    2344:	28 17       	cp	r18, r24
    2346:	39 07       	cpc	r19, r25
    2348:	b8 f4       	brcc	.+46     	; 0x2378 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	89 83       	std	Y+1, r24	; 0x01
    234e:	14 c0       	rjmp	.+40     	; 0x2378 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2350:	ed 81       	ldd	r30, Y+5	; 0x05
    2352:	fe 81       	ldd	r31, Y+6	; 0x06
    2354:	20 81       	ld	r18, Z
    2356:	31 81       	ldd	r19, Z+1	; 0x01
    2358:	8b 81       	ldd	r24, Y+3	; 0x03
    235a:	9c 81       	ldd	r25, Y+4	; 0x04
    235c:	82 17       	cp	r24, r18
    235e:	93 07       	cpc	r25, r19
    2360:	48 f0       	brcs	.+18     	; 0x2374 <vTaskDelayUntil+0x9a>
    2362:	20 91 00 03 	lds	r18, 0x0300
    2366:	30 91 01 03 	lds	r19, 0x0301
    236a:	8b 81       	ldd	r24, Y+3	; 0x03
    236c:	9c 81       	ldd	r25, Y+4	; 0x04
    236e:	28 17       	cp	r18, r24
    2370:	39 07       	cpc	r19, r25
    2372:	10 f4       	brcc	.+4      	; 0x2378 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2378:	ed 81       	ldd	r30, Y+5	; 0x05
    237a:	fe 81       	ldd	r31, Y+6	; 0x06
    237c:	8b 81       	ldd	r24, Y+3	; 0x03
    237e:	9c 81       	ldd	r25, Y+4	; 0x04
    2380:	91 83       	std	Z+1, r25	; 0x01
    2382:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	88 23       	and	r24, r24
    2388:	59 f0       	breq	.+22     	; 0x23a0 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    238a:	80 91 fc 02 	lds	r24, 0x02FC
    238e:	90 91 fd 02 	lds	r25, 0x02FD
    2392:	02 96       	adiw	r24, 0x02	; 2
    2394:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2398:	8b 81       	ldd	r24, Y+3	; 0x03
    239a:	9c 81       	ldd	r25, Y+4	; 0x04
    239c:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    23a0:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    23a4:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	88 23       	and	r24, r24
    23aa:	11 f4       	brne	.+4      	; 0x23b0 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    23ac:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
		}
	}
    23b0:	28 96       	adiw	r28, 0x08	; 8
    23b2:	0f b6       	in	r0, 0x3f	; 63
    23b4:	f8 94       	cli
    23b6:	de bf       	out	0x3e, r29	; 62
    23b8:	0f be       	out	0x3f, r0	; 63
    23ba:	cd bf       	out	0x3d, r28	; 61
    23bc:	cf 91       	pop	r28
    23be:	df 91       	pop	r29
    23c0:	08 95       	ret

000023c2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    23c2:	df 93       	push	r29
    23c4:	cf 93       	push	r28
    23c6:	00 d0       	rcall	.+0      	; 0x23c8 <vTaskDelay+0x6>
    23c8:	00 d0       	rcall	.+0      	; 0x23ca <vTaskDelay+0x8>
    23ca:	0f 92       	push	r0
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	9d 83       	std	Y+5, r25	; 0x05
    23d2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    23d4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    23d6:	8c 81       	ldd	r24, Y+4	; 0x04
    23d8:	9d 81       	ldd	r25, Y+5	; 0x05
    23da:	00 97       	sbiw	r24, 0x00	; 0
    23dc:	d1 f0       	breq	.+52     	; 0x2412 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    23de:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    23e2:	20 91 00 03 	lds	r18, 0x0300
    23e6:	30 91 01 03 	lds	r19, 0x0301
    23ea:	8c 81       	ldd	r24, Y+4	; 0x04
    23ec:	9d 81       	ldd	r25, Y+5	; 0x05
    23ee:	82 0f       	add	r24, r18
    23f0:	93 1f       	adc	r25, r19
    23f2:	9b 83       	std	Y+3, r25	; 0x03
    23f4:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23f6:	80 91 fc 02 	lds	r24, 0x02FC
    23fa:	90 91 fd 02 	lds	r25, 0x02FD
    23fe:	02 96       	adiw	r24, 0x02	; 2
    2400:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2404:	8a 81       	ldd	r24, Y+2	; 0x02
    2406:	9b 81       	ldd	r25, Y+3	; 0x03
    2408:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    240c:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>
    2410:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2412:	89 81       	ldd	r24, Y+1	; 0x01
    2414:	88 23       	and	r24, r24
    2416:	11 f4       	brne	.+4      	; 0x241c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2418:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
		}
	}
    241c:	0f 90       	pop	r0
    241e:	0f 90       	pop	r0
    2420:	0f 90       	pop	r0
    2422:	0f 90       	pop	r0
    2424:	0f 90       	pop	r0
    2426:	cf 91       	pop	r28
    2428:	df 91       	pop	r29
    242a:	08 95       	ret

0000242c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    242c:	af 92       	push	r10
    242e:	bf 92       	push	r11
    2430:	cf 92       	push	r12
    2432:	df 92       	push	r13
    2434:	ef 92       	push	r14
    2436:	ff 92       	push	r15
    2438:	0f 93       	push	r16
    243a:	df 93       	push	r29
    243c:	cf 93       	push	r28
    243e:	0f 92       	push	r0
    2440:	cd b7       	in	r28, 0x3d	; 61
    2442:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2444:	20 e6       	ldi	r18, 0x60	; 96
    2446:	30 e0       	ldi	r19, 0x00	; 0
    2448:	8d e7       	ldi	r24, 0x7D	; 125
    244a:	95 e1       	ldi	r25, 0x15	; 21
    244c:	b9 01       	movw	r22, r18
    244e:	45 e5       	ldi	r20, 0x55	; 85
    2450:	50 e0       	ldi	r21, 0x00	; 0
    2452:	20 e0       	ldi	r18, 0x00	; 0
    2454:	30 e0       	ldi	r19, 0x00	; 0
    2456:	00 e0       	ldi	r16, 0x00	; 0
    2458:	ee 24       	eor	r14, r14
    245a:	ff 24       	eor	r15, r15
    245c:	cc 24       	eor	r12, r12
    245e:	dd 24       	eor	r13, r13
    2460:	aa 24       	eor	r10, r10
    2462:	bb 24       	eor	r11, r11
    2464:	0e 94 1d 10 	call	0x203a	; 0x203a <xTaskGenericCreate>
    2468:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	81 30       	cpi	r24, 0x01	; 1
    246e:	51 f4       	brne	.+20     	; 0x2484 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2470:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2472:	81 e0       	ldi	r24, 0x01	; 1
    2474:	80 93 04 03 	sts	0x0304, r24
		xTickCount = ( portTickType ) 0U;
    2478:	10 92 01 03 	sts	0x0301, r1
    247c:	10 92 00 03 	sts	0x0300, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2480:	0e 94 4d 0a 	call	0x149a	; 0x149a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2484:	0f 90       	pop	r0
    2486:	cf 91       	pop	r28
    2488:	df 91       	pop	r29
    248a:	0f 91       	pop	r16
    248c:	ff 90       	pop	r15
    248e:	ef 90       	pop	r14
    2490:	df 90       	pop	r13
    2492:	cf 90       	pop	r12
    2494:	bf 90       	pop	r11
    2496:	af 90       	pop	r10
    2498:	08 95       	ret

0000249a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    249a:	df 93       	push	r29
    249c:	cf 93       	push	r28
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    24a2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    24a4:	10 92 04 03 	sts	0x0304, r1
	vPortEndScheduler();
    24a8:	0e 94 82 0a 	call	0x1504	; 0x1504 <vPortEndScheduler>
}
    24ac:	cf 91       	pop	r28
    24ae:	df 91       	pop	r29
    24b0:	08 95       	ret

000024b2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    24b2:	df 93       	push	r29
    24b4:	cf 93       	push	r28
    24b6:	cd b7       	in	r28, 0x3d	; 61
    24b8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    24ba:	80 91 05 03 	lds	r24, 0x0305
    24be:	8f 5f       	subi	r24, 0xFF	; 255
    24c0:	80 93 05 03 	sts	0x0305, r24
}
    24c4:	cf 91       	pop	r28
    24c6:	df 91       	pop	r29
    24c8:	08 95       	ret

000024ca <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    24ca:	df 93       	push	r29
    24cc:	cf 93       	push	r28
    24ce:	00 d0       	rcall	.+0      	; 0x24d0 <xTaskResumeAll+0x6>
    24d0:	00 d0       	rcall	.+0      	; 0x24d2 <xTaskResumeAll+0x8>
    24d2:	cd b7       	in	r28, 0x3d	; 61
    24d4:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    24d6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    24d8:	0f b6       	in	r0, 0x3f	; 63
    24da:	f8 94       	cli
    24dc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    24de:	80 91 05 03 	lds	r24, 0x0305
    24e2:	81 50       	subi	r24, 0x01	; 1
    24e4:	80 93 05 03 	sts	0x0305, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    24e8:	80 91 05 03 	lds	r24, 0x0305
    24ec:	88 23       	and	r24, r24
    24ee:	09 f0       	breq	.+2      	; 0x24f2 <xTaskResumeAll+0x28>
    24f0:	6c c0       	rjmp	.+216    	; 0x25ca <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    24f2:	80 91 ff 02 	lds	r24, 0x02FF
    24f6:	88 23       	and	r24, r24
    24f8:	09 f4       	brne	.+2      	; 0x24fc <xTaskResumeAll+0x32>
    24fa:	67 c0       	rjmp	.+206    	; 0x25ca <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    24fc:	19 82       	std	Y+1, r1	; 0x01
    24fe:	41 c0       	rjmp	.+130    	; 0x2582 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2500:	e0 91 52 03 	lds	r30, 0x0352
    2504:	f0 91 53 03 	lds	r31, 0x0353
    2508:	86 81       	ldd	r24, Z+6	; 0x06
    250a:	97 81       	ldd	r25, Z+7	; 0x07
    250c:	9c 83       	std	Y+4, r25	; 0x04
    250e:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2510:	8b 81       	ldd	r24, Y+3	; 0x03
    2512:	9c 81       	ldd	r25, Y+4	; 0x04
    2514:	0c 96       	adiw	r24, 0x0c	; 12
    2516:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    251a:	8b 81       	ldd	r24, Y+3	; 0x03
    251c:	9c 81       	ldd	r25, Y+4	; 0x04
    251e:	02 96       	adiw	r24, 0x02	; 2
    2520:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2524:	eb 81       	ldd	r30, Y+3	; 0x03
    2526:	fc 81       	ldd	r31, Y+4	; 0x04
    2528:	96 89       	ldd	r25, Z+22	; 0x16
    252a:	80 91 03 03 	lds	r24, 0x0303
    252e:	89 17       	cp	r24, r25
    2530:	28 f4       	brcc	.+10     	; 0x253c <xTaskResumeAll+0x72>
    2532:	eb 81       	ldd	r30, Y+3	; 0x03
    2534:	fc 81       	ldd	r31, Y+4	; 0x04
    2536:	86 89       	ldd	r24, Z+22	; 0x16
    2538:	80 93 03 03 	sts	0x0303, r24
    253c:	eb 81       	ldd	r30, Y+3	; 0x03
    253e:	fc 81       	ldd	r31, Y+4	; 0x04
    2540:	86 89       	ldd	r24, Z+22	; 0x16
    2542:	28 2f       	mov	r18, r24
    2544:	30 e0       	ldi	r19, 0x00	; 0
    2546:	c9 01       	movw	r24, r18
    2548:	88 0f       	add	r24, r24
    254a:	99 1f       	adc	r25, r25
    254c:	88 0f       	add	r24, r24
    254e:	99 1f       	adc	r25, r25
    2550:	88 0f       	add	r24, r24
    2552:	99 1f       	adc	r25, r25
    2554:	82 0f       	add	r24, r18
    2556:	93 1f       	adc	r25, r19
    2558:	86 5f       	subi	r24, 0xF6	; 246
    255a:	9c 4f       	sbci	r25, 0xFC	; 252
    255c:	2b 81       	ldd	r18, Y+3	; 0x03
    255e:	3c 81       	ldd	r19, Y+4	; 0x04
    2560:	2e 5f       	subi	r18, 0xFE	; 254
    2562:	3f 4f       	sbci	r19, 0xFF	; 255
    2564:	b9 01       	movw	r22, r18
    2566:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    256a:	eb 81       	ldd	r30, Y+3	; 0x03
    256c:	fc 81       	ldd	r31, Y+4	; 0x04
    256e:	96 89       	ldd	r25, Z+22	; 0x16
    2570:	e0 91 fc 02 	lds	r30, 0x02FC
    2574:	f0 91 fd 02 	lds	r31, 0x02FD
    2578:	86 89       	ldd	r24, Z+22	; 0x16
    257a:	98 17       	cp	r25, r24
    257c:	10 f0       	brcs	.+4      	; 0x2582 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    257e:	81 e0       	ldi	r24, 0x01	; 1
    2580:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2582:	80 91 4d 03 	lds	r24, 0x034D
    2586:	88 23       	and	r24, r24
    2588:	09 f0       	breq	.+2      	; 0x258c <xTaskResumeAll+0xc2>
    258a:	ba cf       	rjmp	.-140    	; 0x2500 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    258c:	80 91 06 03 	lds	r24, 0x0306
    2590:	88 23       	and	r24, r24
    2592:	71 f0       	breq	.+28     	; 0x25b0 <xTaskResumeAll+0xe6>
    2594:	07 c0       	rjmp	.+14     	; 0x25a4 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2596:	0e 94 24 13 	call	0x2648	; 0x2648 <vTaskIncrementTick>
						--uxMissedTicks;
    259a:	80 91 06 03 	lds	r24, 0x0306
    259e:	81 50       	subi	r24, 0x01	; 1
    25a0:	80 93 06 03 	sts	0x0306, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    25a4:	80 91 06 03 	lds	r24, 0x0306
    25a8:	88 23       	and	r24, r24
    25aa:	a9 f7       	brne	.-22     	; 0x2596 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	81 30       	cpi	r24, 0x01	; 1
    25b4:	21 f0       	breq	.+8      	; 0x25be <xTaskResumeAll+0xf4>
    25b6:	80 91 07 03 	lds	r24, 0x0307
    25ba:	81 30       	cpi	r24, 0x01	; 1
    25bc:	31 f4       	brne	.+12     	; 0x25ca <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    25c2:	10 92 07 03 	sts	0x0307, r1
					portYIELD_WITHIN_API();
    25c6:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    25ca:	0f 90       	pop	r0
    25cc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    25ce:	8a 81       	ldd	r24, Y+2	; 0x02
}
    25d0:	0f 90       	pop	r0
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	0f 90       	pop	r0
    25d8:	cf 91       	pop	r28
    25da:	df 91       	pop	r29
    25dc:	08 95       	ret

000025de <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    25de:	df 93       	push	r29
    25e0:	cf 93       	push	r28
    25e2:	00 d0       	rcall	.+0      	; 0x25e4 <xTaskGetTickCount+0x6>
    25e4:	cd b7       	in	r28, 0x3d	; 61
    25e6:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    25e8:	0f b6       	in	r0, 0x3f	; 63
    25ea:	f8 94       	cli
    25ec:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    25ee:	80 91 00 03 	lds	r24, 0x0300
    25f2:	90 91 01 03 	lds	r25, 0x0301
    25f6:	9a 83       	std	Y+2, r25	; 0x02
    25f8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    25fa:	0f 90       	pop	r0
    25fc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    25fe:	89 81       	ldd	r24, Y+1	; 0x01
    2600:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2602:	0f 90       	pop	r0
    2604:	0f 90       	pop	r0
    2606:	cf 91       	pop	r28
    2608:	df 91       	pop	r29
    260a:	08 95       	ret

0000260c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    260c:	df 93       	push	r29
    260e:	cf 93       	push	r28
    2610:	00 d0       	rcall	.+0      	; 0x2612 <xTaskGetTickCountFromISR+0x6>
    2612:	0f 92       	push	r0
    2614:	cd b7       	in	r28, 0x3d	; 61
    2616:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2618:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    261a:	80 91 00 03 	lds	r24, 0x0300
    261e:	90 91 01 03 	lds	r25, 0x0301
    2622:	9b 83       	std	Y+3, r25	; 0x03
    2624:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2626:	8a 81       	ldd	r24, Y+2	; 0x02
    2628:	9b 81       	ldd	r25, Y+3	; 0x03
}
    262a:	0f 90       	pop	r0
    262c:	0f 90       	pop	r0
    262e:	0f 90       	pop	r0
    2630:	cf 91       	pop	r28
    2632:	df 91       	pop	r29
    2634:	08 95       	ret

00002636 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2636:	df 93       	push	r29
    2638:	cf 93       	push	r28
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    263e:	80 91 ff 02 	lds	r24, 0x02FF
}
    2642:	cf 91       	pop	r28
    2644:	df 91       	pop	r29
    2646:	08 95       	ret

00002648 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2648:	df 93       	push	r29
    264a:	cf 93       	push	r28
    264c:	00 d0       	rcall	.+0      	; 0x264e <vTaskIncrementTick+0x6>
    264e:	00 d0       	rcall	.+0      	; 0x2650 <vTaskIncrementTick+0x8>
    2650:	00 d0       	rcall	.+0      	; 0x2652 <vTaskIncrementTick+0xa>
    2652:	cd b7       	in	r28, 0x3d	; 61
    2654:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2656:	80 91 05 03 	lds	r24, 0x0305
    265a:	88 23       	and	r24, r24
    265c:	09 f0       	breq	.+2      	; 0x2660 <vTaskIncrementTick+0x18>
    265e:	bb c0       	rjmp	.+374    	; 0x27d6 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2660:	80 91 00 03 	lds	r24, 0x0300
    2664:	90 91 01 03 	lds	r25, 0x0301
    2668:	01 96       	adiw	r24, 0x01	; 1
    266a:	90 93 01 03 	sts	0x0301, r25
    266e:	80 93 00 03 	sts	0x0300, r24
		if( xTickCount == ( portTickType ) 0U )
    2672:	80 91 00 03 	lds	r24, 0x0300
    2676:	90 91 01 03 	lds	r25, 0x0301
    267a:	00 97       	sbiw	r24, 0x00	; 0
    267c:	d1 f5       	brne	.+116    	; 0x26f2 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    267e:	80 91 49 03 	lds	r24, 0x0349
    2682:	90 91 4a 03 	lds	r25, 0x034A
    2686:	9c 83       	std	Y+4, r25	; 0x04
    2688:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    268a:	80 91 4b 03 	lds	r24, 0x034B
    268e:	90 91 4c 03 	lds	r25, 0x034C
    2692:	90 93 4a 03 	sts	0x034A, r25
    2696:	80 93 49 03 	sts	0x0349, r24
			pxOverflowDelayedTaskList = pxTemp;
    269a:	8b 81       	ldd	r24, Y+3	; 0x03
    269c:	9c 81       	ldd	r25, Y+4	; 0x04
    269e:	90 93 4c 03 	sts	0x034C, r25
    26a2:	80 93 4b 03 	sts	0x034B, r24
			xNumOfOverflows++;
    26a6:	80 91 08 03 	lds	r24, 0x0308
    26aa:	8f 5f       	subi	r24, 0xFF	; 255
    26ac:	80 93 08 03 	sts	0x0308, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    26b0:	e0 91 49 03 	lds	r30, 0x0349
    26b4:	f0 91 4a 03 	lds	r31, 0x034A
    26b8:	80 81       	ld	r24, Z
    26ba:	88 23       	and	r24, r24
    26bc:	39 f4       	brne	.+14     	; 0x26cc <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    26be:	8f ef       	ldi	r24, 0xFF	; 255
    26c0:	9f ef       	ldi	r25, 0xFF	; 255
    26c2:	90 93 66 00 	sts	0x0066, r25
    26c6:	80 93 65 00 	sts	0x0065, r24
    26ca:	13 c0       	rjmp	.+38     	; 0x26f2 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    26cc:	e0 91 49 03 	lds	r30, 0x0349
    26d0:	f0 91 4a 03 	lds	r31, 0x034A
    26d4:	05 80       	ldd	r0, Z+5	; 0x05
    26d6:	f6 81       	ldd	r31, Z+6	; 0x06
    26d8:	e0 2d       	mov	r30, r0
    26da:	86 81       	ldd	r24, Z+6	; 0x06
    26dc:	97 81       	ldd	r25, Z+7	; 0x07
    26de:	9e 83       	std	Y+6, r25	; 0x06
    26e0:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    26e2:	ed 81       	ldd	r30, Y+5	; 0x05
    26e4:	fe 81       	ldd	r31, Y+6	; 0x06
    26e6:	82 81       	ldd	r24, Z+2	; 0x02
    26e8:	93 81       	ldd	r25, Z+3	; 0x03
    26ea:	90 93 66 00 	sts	0x0066, r25
    26ee:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    26f2:	20 91 00 03 	lds	r18, 0x0300
    26f6:	30 91 01 03 	lds	r19, 0x0301
    26fa:	80 91 65 00 	lds	r24, 0x0065
    26fe:	90 91 66 00 	lds	r25, 0x0066
    2702:	28 17       	cp	r18, r24
    2704:	39 07       	cpc	r19, r25
    2706:	08 f4       	brcc	.+2      	; 0x270a <vTaskIncrementTick+0xc2>
    2708:	6b c0       	rjmp	.+214    	; 0x27e0 <vTaskIncrementTick+0x198>
    270a:	e0 91 49 03 	lds	r30, 0x0349
    270e:	f0 91 4a 03 	lds	r31, 0x034A
    2712:	80 81       	ld	r24, Z
    2714:	88 23       	and	r24, r24
    2716:	39 f4       	brne	.+14     	; 0x2726 <vTaskIncrementTick+0xde>
    2718:	8f ef       	ldi	r24, 0xFF	; 255
    271a:	9f ef       	ldi	r25, 0xFF	; 255
    271c:	90 93 66 00 	sts	0x0066, r25
    2720:	80 93 65 00 	sts	0x0065, r24
    2724:	5d c0       	rjmp	.+186    	; 0x27e0 <vTaskIncrementTick+0x198>
    2726:	e0 91 49 03 	lds	r30, 0x0349
    272a:	f0 91 4a 03 	lds	r31, 0x034A
    272e:	05 80       	ldd	r0, Z+5	; 0x05
    2730:	f6 81       	ldd	r31, Z+6	; 0x06
    2732:	e0 2d       	mov	r30, r0
    2734:	86 81       	ldd	r24, Z+6	; 0x06
    2736:	97 81       	ldd	r25, Z+7	; 0x07
    2738:	9e 83       	std	Y+6, r25	; 0x06
    273a:	8d 83       	std	Y+5, r24	; 0x05
    273c:	ed 81       	ldd	r30, Y+5	; 0x05
    273e:	fe 81       	ldd	r31, Y+6	; 0x06
    2740:	82 81       	ldd	r24, Z+2	; 0x02
    2742:	93 81       	ldd	r25, Z+3	; 0x03
    2744:	9a 83       	std	Y+2, r25	; 0x02
    2746:	89 83       	std	Y+1, r24	; 0x01
    2748:	20 91 00 03 	lds	r18, 0x0300
    274c:	30 91 01 03 	lds	r19, 0x0301
    2750:	89 81       	ldd	r24, Y+1	; 0x01
    2752:	9a 81       	ldd	r25, Y+2	; 0x02
    2754:	28 17       	cp	r18, r24
    2756:	39 07       	cpc	r19, r25
    2758:	38 f4       	brcc	.+14     	; 0x2768 <vTaskIncrementTick+0x120>
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	9a 81       	ldd	r25, Y+2	; 0x02
    275e:	90 93 66 00 	sts	0x0066, r25
    2762:	80 93 65 00 	sts	0x0065, r24
    2766:	3c c0       	rjmp	.+120    	; 0x27e0 <vTaskIncrementTick+0x198>
    2768:	8d 81       	ldd	r24, Y+5	; 0x05
    276a:	9e 81       	ldd	r25, Y+6	; 0x06
    276c:	02 96       	adiw	r24, 0x02	; 2
    276e:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
    2772:	ed 81       	ldd	r30, Y+5	; 0x05
    2774:	fe 81       	ldd	r31, Y+6	; 0x06
    2776:	84 89       	ldd	r24, Z+20	; 0x14
    2778:	95 89       	ldd	r25, Z+21	; 0x15
    277a:	00 97       	sbiw	r24, 0x00	; 0
    277c:	29 f0       	breq	.+10     	; 0x2788 <vTaskIncrementTick+0x140>
    277e:	8d 81       	ldd	r24, Y+5	; 0x05
    2780:	9e 81       	ldd	r25, Y+6	; 0x06
    2782:	0c 96       	adiw	r24, 0x0c	; 12
    2784:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
    2788:	ed 81       	ldd	r30, Y+5	; 0x05
    278a:	fe 81       	ldd	r31, Y+6	; 0x06
    278c:	96 89       	ldd	r25, Z+22	; 0x16
    278e:	80 91 03 03 	lds	r24, 0x0303
    2792:	89 17       	cp	r24, r25
    2794:	28 f4       	brcc	.+10     	; 0x27a0 <vTaskIncrementTick+0x158>
    2796:	ed 81       	ldd	r30, Y+5	; 0x05
    2798:	fe 81       	ldd	r31, Y+6	; 0x06
    279a:	86 89       	ldd	r24, Z+22	; 0x16
    279c:	80 93 03 03 	sts	0x0303, r24
    27a0:	ed 81       	ldd	r30, Y+5	; 0x05
    27a2:	fe 81       	ldd	r31, Y+6	; 0x06
    27a4:	86 89       	ldd	r24, Z+22	; 0x16
    27a6:	28 2f       	mov	r18, r24
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	c9 01       	movw	r24, r18
    27ac:	88 0f       	add	r24, r24
    27ae:	99 1f       	adc	r25, r25
    27b0:	88 0f       	add	r24, r24
    27b2:	99 1f       	adc	r25, r25
    27b4:	88 0f       	add	r24, r24
    27b6:	99 1f       	adc	r25, r25
    27b8:	82 0f       	add	r24, r18
    27ba:	93 1f       	adc	r25, r19
    27bc:	ac 01       	movw	r20, r24
    27be:	46 5f       	subi	r20, 0xF6	; 246
    27c0:	5c 4f       	sbci	r21, 0xFC	; 252
    27c2:	8d 81       	ldd	r24, Y+5	; 0x05
    27c4:	9e 81       	ldd	r25, Y+6	; 0x06
    27c6:	9c 01       	movw	r18, r24
    27c8:	2e 5f       	subi	r18, 0xFE	; 254
    27ca:	3f 4f       	sbci	r19, 0xFF	; 255
    27cc:	ca 01       	movw	r24, r20
    27ce:	b9 01       	movw	r22, r18
    27d0:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>
    27d4:	9a cf       	rjmp	.-204    	; 0x270a <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    27d6:	80 91 06 03 	lds	r24, 0x0306
    27da:	8f 5f       	subi	r24, 0xFF	; 255
    27dc:	80 93 06 03 	sts	0x0306, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    27e0:	26 96       	adiw	r28, 0x06	; 6
    27e2:	0f b6       	in	r0, 0x3f	; 63
    27e4:	f8 94       	cli
    27e6:	de bf       	out	0x3e, r29	; 62
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	cd bf       	out	0x3d, r28	; 61
    27ec:	cf 91       	pop	r28
    27ee:	df 91       	pop	r29
    27f0:	08 95       	ret

000027f2 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    27f2:	df 93       	push	r29
    27f4:	cf 93       	push	r28
    27f6:	00 d0       	rcall	.+0      	; 0x27f8 <vTaskSwitchContext+0x6>
    27f8:	cd b7       	in	r28, 0x3d	; 61
    27fa:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    27fc:	80 91 05 03 	lds	r24, 0x0305
    2800:	88 23       	and	r24, r24
    2802:	49 f0       	breq	.+18     	; 0x2816 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	80 93 07 03 	sts	0x0307, r24
    280a:	54 c0       	rjmp	.+168    	; 0x28b4 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    280c:	80 91 03 03 	lds	r24, 0x0303
    2810:	81 50       	subi	r24, 0x01	; 1
    2812:	80 93 03 03 	sts	0x0303, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2816:	80 91 03 03 	lds	r24, 0x0303
    281a:	28 2f       	mov	r18, r24
    281c:	30 e0       	ldi	r19, 0x00	; 0
    281e:	c9 01       	movw	r24, r18
    2820:	88 0f       	add	r24, r24
    2822:	99 1f       	adc	r25, r25
    2824:	88 0f       	add	r24, r24
    2826:	99 1f       	adc	r25, r25
    2828:	88 0f       	add	r24, r24
    282a:	99 1f       	adc	r25, r25
    282c:	82 0f       	add	r24, r18
    282e:	93 1f       	adc	r25, r19
    2830:	fc 01       	movw	r30, r24
    2832:	e6 5f       	subi	r30, 0xF6	; 246
    2834:	fc 4f       	sbci	r31, 0xFC	; 252
    2836:	80 81       	ld	r24, Z
    2838:	88 23       	and	r24, r24
    283a:	41 f3       	breq	.-48     	; 0x280c <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    283c:	80 91 03 03 	lds	r24, 0x0303
    2840:	28 2f       	mov	r18, r24
    2842:	30 e0       	ldi	r19, 0x00	; 0
    2844:	c9 01       	movw	r24, r18
    2846:	88 0f       	add	r24, r24
    2848:	99 1f       	adc	r25, r25
    284a:	88 0f       	add	r24, r24
    284c:	99 1f       	adc	r25, r25
    284e:	88 0f       	add	r24, r24
    2850:	99 1f       	adc	r25, r25
    2852:	82 0f       	add	r24, r18
    2854:	93 1f       	adc	r25, r19
    2856:	86 5f       	subi	r24, 0xF6	; 246
    2858:	9c 4f       	sbci	r25, 0xFC	; 252
    285a:	9a 83       	std	Y+2, r25	; 0x02
    285c:	89 83       	std	Y+1, r24	; 0x01
    285e:	e9 81       	ldd	r30, Y+1	; 0x01
    2860:	fa 81       	ldd	r31, Y+2	; 0x02
    2862:	01 80       	ldd	r0, Z+1	; 0x01
    2864:	f2 81       	ldd	r31, Z+2	; 0x02
    2866:	e0 2d       	mov	r30, r0
    2868:	82 81       	ldd	r24, Z+2	; 0x02
    286a:	93 81       	ldd	r25, Z+3	; 0x03
    286c:	e9 81       	ldd	r30, Y+1	; 0x01
    286e:	fa 81       	ldd	r31, Y+2	; 0x02
    2870:	92 83       	std	Z+2, r25	; 0x02
    2872:	81 83       	std	Z+1, r24	; 0x01
    2874:	e9 81       	ldd	r30, Y+1	; 0x01
    2876:	fa 81       	ldd	r31, Y+2	; 0x02
    2878:	21 81       	ldd	r18, Z+1	; 0x01
    287a:	32 81       	ldd	r19, Z+2	; 0x02
    287c:	89 81       	ldd	r24, Y+1	; 0x01
    287e:	9a 81       	ldd	r25, Y+2	; 0x02
    2880:	03 96       	adiw	r24, 0x03	; 3
    2882:	28 17       	cp	r18, r24
    2884:	39 07       	cpc	r19, r25
    2886:	59 f4       	brne	.+22     	; 0x289e <vTaskSwitchContext+0xac>
    2888:	e9 81       	ldd	r30, Y+1	; 0x01
    288a:	fa 81       	ldd	r31, Y+2	; 0x02
    288c:	01 80       	ldd	r0, Z+1	; 0x01
    288e:	f2 81       	ldd	r31, Z+2	; 0x02
    2890:	e0 2d       	mov	r30, r0
    2892:	82 81       	ldd	r24, Z+2	; 0x02
    2894:	93 81       	ldd	r25, Z+3	; 0x03
    2896:	e9 81       	ldd	r30, Y+1	; 0x01
    2898:	fa 81       	ldd	r31, Y+2	; 0x02
    289a:	92 83       	std	Z+2, r25	; 0x02
    289c:	81 83       	std	Z+1, r24	; 0x01
    289e:	e9 81       	ldd	r30, Y+1	; 0x01
    28a0:	fa 81       	ldd	r31, Y+2	; 0x02
    28a2:	01 80       	ldd	r0, Z+1	; 0x01
    28a4:	f2 81       	ldd	r31, Z+2	; 0x02
    28a6:	e0 2d       	mov	r30, r0
    28a8:	86 81       	ldd	r24, Z+6	; 0x06
    28aa:	97 81       	ldd	r25, Z+7	; 0x07
    28ac:	90 93 fd 02 	sts	0x02FD, r25
    28b0:	80 93 fc 02 	sts	0x02FC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    28b4:	0f 90       	pop	r0
    28b6:	0f 90       	pop	r0
    28b8:	cf 91       	pop	r28
    28ba:	df 91       	pop	r29
    28bc:	08 95       	ret

000028be <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    28be:	df 93       	push	r29
    28c0:	cf 93       	push	r28
    28c2:	00 d0       	rcall	.+0      	; 0x28c4 <vTaskPlaceOnEventList+0x6>
    28c4:	00 d0       	rcall	.+0      	; 0x28c6 <vTaskPlaceOnEventList+0x8>
    28c6:	00 d0       	rcall	.+0      	; 0x28c8 <vTaskPlaceOnEventList+0xa>
    28c8:	cd b7       	in	r28, 0x3d	; 61
    28ca:	de b7       	in	r29, 0x3e	; 62
    28cc:	9c 83       	std	Y+4, r25	; 0x04
    28ce:	8b 83       	std	Y+3, r24	; 0x03
    28d0:	7e 83       	std	Y+6, r23	; 0x06
    28d2:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    28d4:	4b 81       	ldd	r20, Y+3	; 0x03
    28d6:	5c 81       	ldd	r21, Y+4	; 0x04
    28d8:	80 91 fc 02 	lds	r24, 0x02FC
    28dc:	90 91 fd 02 	lds	r25, 0x02FD
    28e0:	9c 01       	movw	r18, r24
    28e2:	24 5f       	subi	r18, 0xF4	; 244
    28e4:	3f 4f       	sbci	r19, 0xFF	; 255
    28e6:	ca 01       	movw	r24, r20
    28e8:	b9 01       	movw	r22, r18
    28ea:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    28ee:	80 91 fc 02 	lds	r24, 0x02FC
    28f2:	90 91 fd 02 	lds	r25, 0x02FD
    28f6:	02 96       	adiw	r24, 0x02	; 2
    28f8:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    28fc:	20 91 00 03 	lds	r18, 0x0300
    2900:	30 91 01 03 	lds	r19, 0x0301
    2904:	8d 81       	ldd	r24, Y+5	; 0x05
    2906:	9e 81       	ldd	r25, Y+6	; 0x06
    2908:	82 0f       	add	r24, r18
    290a:	93 1f       	adc	r25, r19
    290c:	9a 83       	std	Y+2, r25	; 0x02
    290e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	9a 81       	ldd	r25, Y+2	; 0x02
    2914:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2918:	26 96       	adiw	r28, 0x06	; 6
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	de bf       	out	0x3e, r29	; 62
    2920:	0f be       	out	0x3f, r0	; 63
    2922:	cd bf       	out	0x3d, r28	; 61
    2924:	cf 91       	pop	r28
    2926:	df 91       	pop	r29
    2928:	08 95       	ret

0000292a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    292a:	df 93       	push	r29
    292c:	cf 93       	push	r28
    292e:	00 d0       	rcall	.+0      	; 0x2930 <xTaskRemoveFromEventList+0x6>
    2930:	00 d0       	rcall	.+0      	; 0x2932 <xTaskRemoveFromEventList+0x8>
    2932:	0f 92       	push	r0
    2934:	cd b7       	in	r28, 0x3d	; 61
    2936:	de b7       	in	r29, 0x3e	; 62
    2938:	9d 83       	std	Y+5, r25	; 0x05
    293a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    293c:	ec 81       	ldd	r30, Y+4	; 0x04
    293e:	fd 81       	ldd	r31, Y+5	; 0x05
    2940:	05 80       	ldd	r0, Z+5	; 0x05
    2942:	f6 81       	ldd	r31, Z+6	; 0x06
    2944:	e0 2d       	mov	r30, r0
    2946:	86 81       	ldd	r24, Z+6	; 0x06
    2948:	97 81       	ldd	r25, Z+7	; 0x07
    294a:	9b 83       	std	Y+3, r25	; 0x03
    294c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    294e:	8a 81       	ldd	r24, Y+2	; 0x02
    2950:	9b 81       	ldd	r25, Y+3	; 0x03
    2952:	0c 96       	adiw	r24, 0x0c	; 12
    2954:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2958:	80 91 05 03 	lds	r24, 0x0305
    295c:	88 23       	and	r24, r24
    295e:	61 f5       	brne	.+88     	; 0x29b8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2960:	8a 81       	ldd	r24, Y+2	; 0x02
    2962:	9b 81       	ldd	r25, Y+3	; 0x03
    2964:	02 96       	adiw	r24, 0x02	; 2
    2966:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    296a:	ea 81       	ldd	r30, Y+2	; 0x02
    296c:	fb 81       	ldd	r31, Y+3	; 0x03
    296e:	96 89       	ldd	r25, Z+22	; 0x16
    2970:	80 91 03 03 	lds	r24, 0x0303
    2974:	89 17       	cp	r24, r25
    2976:	28 f4       	brcc	.+10     	; 0x2982 <xTaskRemoveFromEventList+0x58>
    2978:	ea 81       	ldd	r30, Y+2	; 0x02
    297a:	fb 81       	ldd	r31, Y+3	; 0x03
    297c:	86 89       	ldd	r24, Z+22	; 0x16
    297e:	80 93 03 03 	sts	0x0303, r24
    2982:	ea 81       	ldd	r30, Y+2	; 0x02
    2984:	fb 81       	ldd	r31, Y+3	; 0x03
    2986:	86 89       	ldd	r24, Z+22	; 0x16
    2988:	28 2f       	mov	r18, r24
    298a:	30 e0       	ldi	r19, 0x00	; 0
    298c:	c9 01       	movw	r24, r18
    298e:	88 0f       	add	r24, r24
    2990:	99 1f       	adc	r25, r25
    2992:	88 0f       	add	r24, r24
    2994:	99 1f       	adc	r25, r25
    2996:	88 0f       	add	r24, r24
    2998:	99 1f       	adc	r25, r25
    299a:	82 0f       	add	r24, r18
    299c:	93 1f       	adc	r25, r19
    299e:	ac 01       	movw	r20, r24
    29a0:	46 5f       	subi	r20, 0xF6	; 246
    29a2:	5c 4f       	sbci	r21, 0xFC	; 252
    29a4:	8a 81       	ldd	r24, Y+2	; 0x02
    29a6:	9b 81       	ldd	r25, Y+3	; 0x03
    29a8:	9c 01       	movw	r18, r24
    29aa:	2e 5f       	subi	r18, 0xFE	; 254
    29ac:	3f 4f       	sbci	r19, 0xFF	; 255
    29ae:	ca 01       	movw	r24, r20
    29b0:	b9 01       	movw	r22, r18
    29b2:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>
    29b6:	0a c0       	rjmp	.+20     	; 0x29cc <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    29b8:	8a 81       	ldd	r24, Y+2	; 0x02
    29ba:	9b 81       	ldd	r25, Y+3	; 0x03
    29bc:	9c 01       	movw	r18, r24
    29be:	24 5f       	subi	r18, 0xF4	; 244
    29c0:	3f 4f       	sbci	r19, 0xFF	; 255
    29c2:	8d e4       	ldi	r24, 0x4D	; 77
    29c4:	93 e0       	ldi	r25, 0x03	; 3
    29c6:	b9 01       	movw	r22, r18
    29c8:	0e 94 64 07 	call	0xec8	; 0xec8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    29cc:	ea 81       	ldd	r30, Y+2	; 0x02
    29ce:	fb 81       	ldd	r31, Y+3	; 0x03
    29d0:	96 89       	ldd	r25, Z+22	; 0x16
    29d2:	e0 91 fc 02 	lds	r30, 0x02FC
    29d6:	f0 91 fd 02 	lds	r31, 0x02FD
    29da:	86 89       	ldd	r24, Z+22	; 0x16
    29dc:	98 17       	cp	r25, r24
    29de:	18 f0       	brcs	.+6      	; 0x29e6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	89 83       	std	Y+1, r24	; 0x01
    29e4:	01 c0       	rjmp	.+2      	; 0x29e8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    29e6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    29e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
    29f4:	cf 91       	pop	r28
    29f6:	df 91       	pop	r29
    29f8:	08 95       	ret

000029fa <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    29fa:	df 93       	push	r29
    29fc:	cf 93       	push	r28
    29fe:	00 d0       	rcall	.+0      	; 0x2a00 <vTaskSetTimeOutState+0x6>
    2a00:	cd b7       	in	r28, 0x3d	; 61
    2a02:	de b7       	in	r29, 0x3e	; 62
    2a04:	9a 83       	std	Y+2, r25	; 0x02
    2a06:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a08:	80 91 08 03 	lds	r24, 0x0308
    2a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a10:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2a12:	80 91 00 03 	lds	r24, 0x0300
    2a16:	90 91 01 03 	lds	r25, 0x0301
    2a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1e:	92 83       	std	Z+2, r25	; 0x02
    2a20:	81 83       	std	Z+1, r24	; 0x01
}
    2a22:	0f 90       	pop	r0
    2a24:	0f 90       	pop	r0
    2a26:	cf 91       	pop	r28
    2a28:	df 91       	pop	r29
    2a2a:	08 95       	ret

00002a2c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2a2c:	df 93       	push	r29
    2a2e:	cf 93       	push	r28
    2a30:	00 d0       	rcall	.+0      	; 0x2a32 <xTaskCheckForTimeOut+0x6>
    2a32:	00 d0       	rcall	.+0      	; 0x2a34 <xTaskCheckForTimeOut+0x8>
    2a34:	0f 92       	push	r0
    2a36:	cd b7       	in	r28, 0x3d	; 61
    2a38:	de b7       	in	r29, 0x3e	; 62
    2a3a:	9b 83       	std	Y+3, r25	; 0x03
    2a3c:	8a 83       	std	Y+2, r24	; 0x02
    2a3e:	7d 83       	std	Y+5, r23	; 0x05
    2a40:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2a42:	0f b6       	in	r0, 0x3f	; 63
    2a44:	f8 94       	cli
    2a46:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2a48:	ea 81       	ldd	r30, Y+2	; 0x02
    2a4a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a4c:	90 81       	ld	r25, Z
    2a4e:	80 91 08 03 	lds	r24, 0x0308
    2a52:	98 17       	cp	r25, r24
    2a54:	71 f0       	breq	.+28     	; 0x2a72 <xTaskCheckForTimeOut+0x46>
    2a56:	ea 81       	ldd	r30, Y+2	; 0x02
    2a58:	fb 81       	ldd	r31, Y+3	; 0x03
    2a5a:	21 81       	ldd	r18, Z+1	; 0x01
    2a5c:	32 81       	ldd	r19, Z+2	; 0x02
    2a5e:	80 91 00 03 	lds	r24, 0x0300
    2a62:	90 91 01 03 	lds	r25, 0x0301
    2a66:	82 17       	cp	r24, r18
    2a68:	93 07       	cpc	r25, r19
    2a6a:	18 f0       	brcs	.+6      	; 0x2a72 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	89 83       	std	Y+1, r24	; 0x01
    2a70:	2f c0       	rjmp	.+94     	; 0x2ad0 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2a72:	20 91 00 03 	lds	r18, 0x0300
    2a76:	30 91 01 03 	lds	r19, 0x0301
    2a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2a7e:	81 81       	ldd	r24, Z+1	; 0x01
    2a80:	92 81       	ldd	r25, Z+2	; 0x02
    2a82:	28 1b       	sub	r18, r24
    2a84:	39 0b       	sbc	r19, r25
    2a86:	ec 81       	ldd	r30, Y+4	; 0x04
    2a88:	fd 81       	ldd	r31, Y+5	; 0x05
    2a8a:	80 81       	ld	r24, Z
    2a8c:	91 81       	ldd	r25, Z+1	; 0x01
    2a8e:	28 17       	cp	r18, r24
    2a90:	39 07       	cpc	r19, r25
    2a92:	e0 f4       	brcc	.+56     	; 0x2acc <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2a94:	ec 81       	ldd	r30, Y+4	; 0x04
    2a96:	fd 81       	ldd	r31, Y+5	; 0x05
    2a98:	40 81       	ld	r20, Z
    2a9a:	51 81       	ldd	r21, Z+1	; 0x01
    2a9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2aa0:	21 81       	ldd	r18, Z+1	; 0x01
    2aa2:	32 81       	ldd	r19, Z+2	; 0x02
    2aa4:	80 91 00 03 	lds	r24, 0x0300
    2aa8:	90 91 01 03 	lds	r25, 0x0301
    2aac:	b9 01       	movw	r22, r18
    2aae:	68 1b       	sub	r22, r24
    2ab0:	79 0b       	sbc	r23, r25
    2ab2:	cb 01       	movw	r24, r22
    2ab4:	84 0f       	add	r24, r20
    2ab6:	95 1f       	adc	r25, r21
    2ab8:	ec 81       	ldd	r30, Y+4	; 0x04
    2aba:	fd 81       	ldd	r31, Y+5	; 0x05
    2abc:	91 83       	std	Z+1, r25	; 0x01
    2abe:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2ac0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac4:	0e 94 fd 14 	call	0x29fa	; 0x29fa <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ac8:	19 82       	std	Y+1, r1	; 0x01
    2aca:	02 c0       	rjmp	.+4      	; 0x2ad0 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2acc:	81 e0       	ldi	r24, 0x01	; 1
    2ace:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ad0:	0f 90       	pop	r0
    2ad2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ad6:	0f 90       	pop	r0
    2ad8:	0f 90       	pop	r0
    2ada:	0f 90       	pop	r0
    2adc:	0f 90       	pop	r0
    2ade:	0f 90       	pop	r0
    2ae0:	cf 91       	pop	r28
    2ae2:	df 91       	pop	r29
    2ae4:	08 95       	ret

00002ae6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2ae6:	df 93       	push	r29
    2ae8:	cf 93       	push	r28
    2aea:	cd b7       	in	r28, 0x3d	; 61
    2aec:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2aee:	81 e0       	ldi	r24, 0x01	; 1
    2af0:	80 93 07 03 	sts	0x0307, r24
}
    2af4:	cf 91       	pop	r28
    2af6:	df 91       	pop	r29
    2af8:	08 95       	ret

00002afa <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2afa:	df 93       	push	r29
    2afc:	cf 93       	push	r28
    2afe:	00 d0       	rcall	.+0      	; 0x2b00 <prvIdleTask+0x6>
    2b00:	cd b7       	in	r28, 0x3d	; 61
    2b02:	de b7       	in	r29, 0x3e	; 62
    2b04:	9a 83       	std	Y+2, r25	; 0x02
    2b06:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2b08:	0e 94 1b 16 	call	0x2c36	; 0x2c36 <prvCheckTasksWaitingTermination>
    2b0c:	fd cf       	rjmp	.-6      	; 0x2b08 <prvIdleTask+0xe>

00002b0e <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2b0e:	0f 93       	push	r16
    2b10:	1f 93       	push	r17
    2b12:	df 93       	push	r29
    2b14:	cf 93       	push	r28
    2b16:	cd b7       	in	r28, 0x3d	; 61
    2b18:	de b7       	in	r29, 0x3e	; 62
    2b1a:	29 97       	sbiw	r28, 0x09	; 9
    2b1c:	0f b6       	in	r0, 0x3f	; 63
    2b1e:	f8 94       	cli
    2b20:	de bf       	out	0x3e, r29	; 62
    2b22:	0f be       	out	0x3f, r0	; 63
    2b24:	cd bf       	out	0x3d, r28	; 61
    2b26:	9a 83       	std	Y+2, r25	; 0x02
    2b28:	89 83       	std	Y+1, r24	; 0x01
    2b2a:	7c 83       	std	Y+4, r23	; 0x04
    2b2c:	6b 83       	std	Y+3, r22	; 0x03
    2b2e:	4d 83       	std	Y+5, r20	; 0x05
    2b30:	3f 83       	std	Y+7, r19	; 0x07
    2b32:	2e 83       	std	Y+6, r18	; 0x06
    2b34:	19 87       	std	Y+9, r17	; 0x09
    2b36:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2b38:	89 81       	ldd	r24, Y+1	; 0x01
    2b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3c:	49 96       	adiw	r24, 0x19	; 25
    2b3e:	2b 81       	ldd	r18, Y+3	; 0x03
    2b40:	3c 81       	ldd	r19, Y+4	; 0x04
    2b42:	b9 01       	movw	r22, r18
    2b44:	48 e0       	ldi	r20, 0x08	; 8
    2b46:	50 e0       	ldi	r21, 0x00	; 0
    2b48:	0e 94 18 17 	call	0x2e30	; 0x2e30 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b50:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    2b52:	8d 81       	ldd	r24, Y+5	; 0x05
    2b54:	85 30       	cpi	r24, 0x05	; 5
    2b56:	10 f0       	brcs	.+4      	; 0x2b5c <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2b58:	84 e0       	ldi	r24, 0x04	; 4
    2b5a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b60:	8d 81       	ldd	r24, Y+5	; 0x05
    2b62:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2b64:	89 81       	ldd	r24, Y+1	; 0x01
    2b66:	9a 81       	ldd	r25, Y+2	; 0x02
    2b68:	02 96       	adiw	r24, 0x02	; 2
    2b6a:	0e 94 54 07 	call	0xea8	; 0xea8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2b6e:	89 81       	ldd	r24, Y+1	; 0x01
    2b70:	9a 81       	ldd	r25, Y+2	; 0x02
    2b72:	0c 96       	adiw	r24, 0x0c	; 12
    2b74:	0e 94 54 07 	call	0xea8	; 0xea8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2b78:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7c:	89 81       	ldd	r24, Y+1	; 0x01
    2b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b80:	91 87       	std	Z+9, r25	; 0x09
    2b82:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2b84:	8d 81       	ldd	r24, Y+5	; 0x05
    2b86:	28 2f       	mov	r18, r24
    2b88:	30 e0       	ldi	r19, 0x00	; 0
    2b8a:	85 e0       	ldi	r24, 0x05	; 5
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	82 1b       	sub	r24, r18
    2b90:	93 0b       	sbc	r25, r19
    2b92:	e9 81       	ldd	r30, Y+1	; 0x01
    2b94:	fa 81       	ldd	r31, Y+2	; 0x02
    2b96:	95 87       	std	Z+13, r25	; 0x0d
    2b98:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba2:	93 8b       	std	Z+19, r25	; 0x13
    2ba4:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2ba6:	29 96       	adiw	r28, 0x09	; 9
    2ba8:	0f b6       	in	r0, 0x3f	; 63
    2baa:	f8 94       	cli
    2bac:	de bf       	out	0x3e, r29	; 62
    2bae:	0f be       	out	0x3f, r0	; 63
    2bb0:	cd bf       	out	0x3d, r28	; 61
    2bb2:	cf 91       	pop	r28
    2bb4:	df 91       	pop	r29
    2bb6:	1f 91       	pop	r17
    2bb8:	0f 91       	pop	r16
    2bba:	08 95       	ret

00002bbc <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2bbc:	df 93       	push	r29
    2bbe:	cf 93       	push	r28
    2bc0:	0f 92       	push	r0
    2bc2:	cd b7       	in	r28, 0x3d	; 61
    2bc4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2bc6:	19 82       	std	Y+1, r1	; 0x01
    2bc8:	13 c0       	rjmp	.+38     	; 0x2bf0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2bca:	89 81       	ldd	r24, Y+1	; 0x01
    2bcc:	28 2f       	mov	r18, r24
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	c9 01       	movw	r24, r18
    2bd2:	88 0f       	add	r24, r24
    2bd4:	99 1f       	adc	r25, r25
    2bd6:	88 0f       	add	r24, r24
    2bd8:	99 1f       	adc	r25, r25
    2bda:	88 0f       	add	r24, r24
    2bdc:	99 1f       	adc	r25, r25
    2bde:	82 0f       	add	r24, r18
    2be0:	93 1f       	adc	r25, r19
    2be2:	86 5f       	subi	r24, 0xF6	; 246
    2be4:	9c 4f       	sbci	r25, 0xFC	; 252
    2be6:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2bea:	89 81       	ldd	r24, Y+1	; 0x01
    2bec:	8f 5f       	subi	r24, 0xFF	; 255
    2bee:	89 83       	std	Y+1, r24	; 0x01
    2bf0:	89 81       	ldd	r24, Y+1	; 0x01
    2bf2:	85 30       	cpi	r24, 0x05	; 5
    2bf4:	50 f3       	brcs	.-44     	; 0x2bca <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2bf6:	87 e3       	ldi	r24, 0x37	; 55
    2bf8:	93 e0       	ldi	r25, 0x03	; 3
    2bfa:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2bfe:	80 e4       	ldi	r24, 0x40	; 64
    2c00:	93 e0       	ldi	r25, 0x03	; 3
    2c02:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2c06:	8d e4       	ldi	r24, 0x4D	; 77
    2c08:	93 e0       	ldi	r25, 0x03	; 3
    2c0a:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2c0e:	86 e5       	ldi	r24, 0x56	; 86
    2c10:	93 e0       	ldi	r25, 0x03	; 3
    2c12:	0e 94 2a 07 	call	0xe54	; 0xe54 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2c16:	87 e3       	ldi	r24, 0x37	; 55
    2c18:	93 e0       	ldi	r25, 0x03	; 3
    2c1a:	90 93 4a 03 	sts	0x034A, r25
    2c1e:	80 93 49 03 	sts	0x0349, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2c22:	80 e4       	ldi	r24, 0x40	; 64
    2c24:	93 e0       	ldi	r25, 0x03	; 3
    2c26:	90 93 4c 03 	sts	0x034C, r25
    2c2a:	80 93 4b 03 	sts	0x034B, r24
}
    2c2e:	0f 90       	pop	r0
    2c30:	cf 91       	pop	r28
    2c32:	df 91       	pop	r29
    2c34:	08 95       	ret

00002c36 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2c36:	df 93       	push	r29
    2c38:	cf 93       	push	r28
    2c3a:	00 d0       	rcall	.+0      	; 0x2c3c <prvCheckTasksWaitingTermination+0x6>
    2c3c:	0f 92       	push	r0
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    2c42:	80 91 fe 02 	lds	r24, 0x02FE
    2c46:	88 23       	and	r24, r24
    2c48:	71 f1       	breq	.+92     	; 0x2ca6 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2c4a:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2c4e:	80 91 56 03 	lds	r24, 0x0356
    2c52:	1b 82       	std	Y+3, r1	; 0x03
    2c54:	88 23       	and	r24, r24
    2c56:	11 f4       	brne	.+4      	; 0x2c5c <prvCheckTasksWaitingTermination+0x26>
    2c58:	81 e0       	ldi	r24, 0x01	; 1
    2c5a:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2c5c:	0e 94 65 12 	call	0x24ca	; 0x24ca <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2c60:	8b 81       	ldd	r24, Y+3	; 0x03
    2c62:	88 23       	and	r24, r24
    2c64:	01 f5       	brne	.+64     	; 0x2ca6 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2c66:	0f b6       	in	r0, 0x3f	; 63
    2c68:	f8 94       	cli
    2c6a:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2c6c:	e0 91 5b 03 	lds	r30, 0x035B
    2c70:	f0 91 5c 03 	lds	r31, 0x035C
    2c74:	86 81       	ldd	r24, Z+6	; 0x06
    2c76:	97 81       	ldd	r25, Z+7	; 0x07
    2c78:	9a 83       	std	Y+2, r25	; 0x02
    2c7a:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2c7c:	89 81       	ldd	r24, Y+1	; 0x01
    2c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c80:	02 96       	adiw	r24, 0x02	; 2
    2c82:	0e 94 1c 08 	call	0x1038	; 0x1038 <vListRemove>
					--uxCurrentNumberOfTasks;
    2c86:	80 91 ff 02 	lds	r24, 0x02FF
    2c8a:	81 50       	subi	r24, 0x01	; 1
    2c8c:	80 93 ff 02 	sts	0x02FF, r24
					--uxTasksDeleted;
    2c90:	80 91 fe 02 	lds	r24, 0x02FE
    2c94:	81 50       	subi	r24, 0x01	; 1
    2c96:	80 93 fe 02 	sts	0x02FE, r24
				}
				taskEXIT_CRITICAL();
    2c9a:	0f 90       	pop	r0
    2c9c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2c9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ca0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca2:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2ca6:	0f 90       	pop	r0
    2ca8:	0f 90       	pop	r0
    2caa:	0f 90       	pop	r0
    2cac:	cf 91       	pop	r28
    2cae:	df 91       	pop	r29
    2cb0:	08 95       	ret

00002cb2 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2cb2:	df 93       	push	r29
    2cb4:	cf 93       	push	r28
    2cb6:	00 d0       	rcall	.+0      	; 0x2cb8 <prvAddCurrentTaskToDelayedList+0x6>
    2cb8:	cd b7       	in	r28, 0x3d	; 61
    2cba:	de b7       	in	r29, 0x3e	; 62
    2cbc:	9a 83       	std	Y+2, r25	; 0x02
    2cbe:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2cc0:	e0 91 fc 02 	lds	r30, 0x02FC
    2cc4:	f0 91 fd 02 	lds	r31, 0x02FD
    2cc8:	89 81       	ldd	r24, Y+1	; 0x01
    2cca:	9a 81       	ldd	r25, Y+2	; 0x02
    2ccc:	93 83       	std	Z+3, r25	; 0x03
    2cce:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2cd0:	20 91 00 03 	lds	r18, 0x0300
    2cd4:	30 91 01 03 	lds	r19, 0x0301
    2cd8:	89 81       	ldd	r24, Y+1	; 0x01
    2cda:	9a 81       	ldd	r25, Y+2	; 0x02
    2cdc:	82 17       	cp	r24, r18
    2cde:	93 07       	cpc	r25, r19
    2ce0:	70 f4       	brcc	.+28     	; 0x2cfe <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ce2:	80 91 4b 03 	lds	r24, 0x034B
    2ce6:	90 91 4c 03 	lds	r25, 0x034C
    2cea:	20 91 fc 02 	lds	r18, 0x02FC
    2cee:	30 91 fd 02 	lds	r19, 0x02FD
    2cf2:	2e 5f       	subi	r18, 0xFE	; 254
    2cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf6:	b9 01       	movw	r22, r18
    2cf8:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>
    2cfc:	1e c0       	rjmp	.+60     	; 0x2d3a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cfe:	40 91 49 03 	lds	r20, 0x0349
    2d02:	50 91 4a 03 	lds	r21, 0x034A
    2d06:	80 91 fc 02 	lds	r24, 0x02FC
    2d0a:	90 91 fd 02 	lds	r25, 0x02FD
    2d0e:	9c 01       	movw	r18, r24
    2d10:	2e 5f       	subi	r18, 0xFE	; 254
    2d12:	3f 4f       	sbci	r19, 0xFF	; 255
    2d14:	ca 01       	movw	r24, r20
    2d16:	b9 01       	movw	r22, r18
    2d18:	0e 94 b0 07 	call	0xf60	; 0xf60 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2d1c:	20 91 65 00 	lds	r18, 0x0065
    2d20:	30 91 66 00 	lds	r19, 0x0066
    2d24:	89 81       	ldd	r24, Y+1	; 0x01
    2d26:	9a 81       	ldd	r25, Y+2	; 0x02
    2d28:	82 17       	cp	r24, r18
    2d2a:	93 07       	cpc	r25, r19
    2d2c:	30 f4       	brcc	.+12     	; 0x2d3a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2d2e:	89 81       	ldd	r24, Y+1	; 0x01
    2d30:	9a 81       	ldd	r25, Y+2	; 0x02
    2d32:	90 93 66 00 	sts	0x0066, r25
    2d36:	80 93 65 00 	sts	0x0065, r24
		}
	}
}
    2d3a:	0f 90       	pop	r0
    2d3c:	0f 90       	pop	r0
    2d3e:	cf 91       	pop	r28
    2d40:	df 91       	pop	r29
    2d42:	08 95       	ret

00002d44 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2d44:	df 93       	push	r29
    2d46:	cf 93       	push	r28
    2d48:	cd b7       	in	r28, 0x3d	; 61
    2d4a:	de b7       	in	r29, 0x3e	; 62
    2d4c:	28 97       	sbiw	r28, 0x08	; 8
    2d4e:	0f b6       	in	r0, 0x3f	; 63
    2d50:	f8 94       	cli
    2d52:	de bf       	out	0x3e, r29	; 62
    2d54:	0f be       	out	0x3f, r0	; 63
    2d56:	cd bf       	out	0x3d, r28	; 61
    2d58:	9c 83       	std	Y+4, r25	; 0x04
    2d5a:	8b 83       	std	Y+3, r24	; 0x03
    2d5c:	7e 83       	std	Y+6, r23	; 0x06
    2d5e:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2d60:	81 e2       	ldi	r24, 0x21	; 33
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	0e 94 be 06 	call	0xd7c	; 0xd7c <pvPortMalloc>
    2d68:	9a 83       	std	Y+2, r25	; 0x02
    2d6a:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2d6c:	89 81       	ldd	r24, Y+1	; 0x01
    2d6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d70:	00 97       	sbiw	r24, 0x00	; 0
    2d72:	69 f1       	breq	.+90     	; 0x2dce <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2d74:	8d 81       	ldd	r24, Y+5	; 0x05
    2d76:	9e 81       	ldd	r25, Y+6	; 0x06
    2d78:	00 97       	sbiw	r24, 0x00	; 0
    2d7a:	39 f4       	brne	.+14     	; 0x2d8a <prvAllocateTCBAndStack+0x46>
    2d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d80:	0e 94 be 06 	call	0xd7c	; 0xd7c <pvPortMalloc>
    2d84:	98 87       	std	Y+8, r25	; 0x08
    2d86:	8f 83       	std	Y+7, r24	; 0x07
    2d88:	04 c0       	rjmp	.+8      	; 0x2d92 <prvAllocateTCBAndStack+0x4e>
    2d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d8e:	98 87       	std	Y+8, r25	; 0x08
    2d90:	8f 83       	std	Y+7, r24	; 0x07
    2d92:	e9 81       	ldd	r30, Y+1	; 0x01
    2d94:	fa 81       	ldd	r31, Y+2	; 0x02
    2d96:	8f 81       	ldd	r24, Y+7	; 0x07
    2d98:	98 85       	ldd	r25, Y+8	; 0x08
    2d9a:	90 8f       	std	Z+24, r25	; 0x18
    2d9c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2da0:	fa 81       	ldd	r31, Y+2	; 0x02
    2da2:	87 89       	ldd	r24, Z+23	; 0x17
    2da4:	90 8d       	ldd	r25, Z+24	; 0x18
    2da6:	00 97       	sbiw	r24, 0x00	; 0
    2da8:	39 f4       	brne	.+14     	; 0x2db8 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2daa:	89 81       	ldd	r24, Y+1	; 0x01
    2dac:	9a 81       	ldd	r25, Y+2	; 0x02
    2dae:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
			pxNewTCB = NULL;
    2db2:	1a 82       	std	Y+2, r1	; 0x02
    2db4:	19 82       	std	Y+1, r1	; 0x01
    2db6:	0b c0       	rjmp	.+22     	; 0x2dce <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2db8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dba:	fa 81       	ldd	r31, Y+2	; 0x02
    2dbc:	87 89       	ldd	r24, Z+23	; 0x17
    2dbe:	90 8d       	ldd	r25, Z+24	; 0x18
    2dc0:	2b 81       	ldd	r18, Y+3	; 0x03
    2dc2:	3c 81       	ldd	r19, Y+4	; 0x04
    2dc4:	65 ea       	ldi	r22, 0xA5	; 165
    2dc6:	70 e0       	ldi	r23, 0x00	; 0
    2dc8:	a9 01       	movw	r20, r18
    2dca:	0e 94 11 17 	call	0x2e22	; 0x2e22 <memset>
		}
	}

	return pxNewTCB;
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2dd2:	28 96       	adiw	r28, 0x08	; 8
    2dd4:	0f b6       	in	r0, 0x3f	; 63
    2dd6:	f8 94       	cli
    2dd8:	de bf       	out	0x3e, r29	; 62
    2dda:	0f be       	out	0x3f, r0	; 63
    2ddc:	cd bf       	out	0x3d, r28	; 61
    2dde:	cf 91       	pop	r28
    2de0:	df 91       	pop	r29
    2de2:	08 95       	ret

00002de4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2de4:	df 93       	push	r29
    2de6:	cf 93       	push	r28
    2de8:	00 d0       	rcall	.+0      	; 0x2dea <prvDeleteTCB+0x6>
    2dea:	cd b7       	in	r28, 0x3d	; 61
    2dec:	de b7       	in	r29, 0x3e	; 62
    2dee:	9a 83       	std	Y+2, r25	; 0x02
    2df0:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2df2:	e9 81       	ldd	r30, Y+1	; 0x01
    2df4:	fa 81       	ldd	r31, Y+2	; 0x02
    2df6:	87 89       	ldd	r24, Z+23	; 0x17
    2df8:	90 8d       	ldd	r25, Z+24	; 0x18
    2dfa:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
		vPortFree( pxTCB );
    2dfe:	89 81       	ldd	r24, Y+1	; 0x01
    2e00:	9a 81       	ldd	r25, Y+2	; 0x02
    2e02:	0e 94 04 07 	call	0xe08	; 0xe08 <vPortFree>
	}
    2e06:	0f 90       	pop	r0
    2e08:	0f 90       	pop	r0
    2e0a:	cf 91       	pop	r28
    2e0c:	df 91       	pop	r29
    2e0e:	08 95       	ret

00002e10 <memcpy>:
    2e10:	fb 01       	movw	r30, r22
    2e12:	dc 01       	movw	r26, r24
    2e14:	02 c0       	rjmp	.+4      	; 0x2e1a <memcpy+0xa>
    2e16:	01 90       	ld	r0, Z+
    2e18:	0d 92       	st	X+, r0
    2e1a:	41 50       	subi	r20, 0x01	; 1
    2e1c:	50 40       	sbci	r21, 0x00	; 0
    2e1e:	d8 f7       	brcc	.-10     	; 0x2e16 <memcpy+0x6>
    2e20:	08 95       	ret

00002e22 <memset>:
    2e22:	dc 01       	movw	r26, r24
    2e24:	01 c0       	rjmp	.+2      	; 0x2e28 <memset+0x6>
    2e26:	6d 93       	st	X+, r22
    2e28:	41 50       	subi	r20, 0x01	; 1
    2e2a:	50 40       	sbci	r21, 0x00	; 0
    2e2c:	e0 f7       	brcc	.-8      	; 0x2e26 <memset+0x4>
    2e2e:	08 95       	ret

00002e30 <strncpy>:
    2e30:	fb 01       	movw	r30, r22
    2e32:	dc 01       	movw	r26, r24
    2e34:	41 50       	subi	r20, 0x01	; 1
    2e36:	50 40       	sbci	r21, 0x00	; 0
    2e38:	48 f0       	brcs	.+18     	; 0x2e4c <strncpy+0x1c>
    2e3a:	01 90       	ld	r0, Z+
    2e3c:	0d 92       	st	X+, r0
    2e3e:	00 20       	and	r0, r0
    2e40:	c9 f7       	brne	.-14     	; 0x2e34 <strncpy+0x4>
    2e42:	01 c0       	rjmp	.+2      	; 0x2e46 <strncpy+0x16>
    2e44:	1d 92       	st	X+, r1
    2e46:	41 50       	subi	r20, 0x01	; 1
    2e48:	50 40       	sbci	r21, 0x00	; 0
    2e4a:	e0 f7       	brcc	.-8      	; 0x2e44 <strncpy+0x14>
    2e4c:	08 95       	ret

00002e4e <_exit>:
    2e4e:	f8 94       	cli

00002e50 <__stop_program>:
    2e50:	ff cf       	rjmp	.-2      	; 0x2e50 <__stop_program>
